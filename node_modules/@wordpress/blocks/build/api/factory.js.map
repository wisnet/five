{"version":3,"sources":["/Users/riad/Workspace/a8c/gutenberg/packages/blocks/src/api/factory.js"],"names":["createBlock","name","attributes","innerBlocks","blockType","sanitizedAttributes","result","schema","key","value","undefined","hasOwnProperty","default","indexOf","source","Array","isArray","clientId","isValid","cloneBlock","block","mergeAttributes","newInnerBlocks","map","innerBlock","isPossibleTransformForSource","transform","direction","blocks","isMultiBlock","length","isValidForMultiBlocks","isBlockType","type","sourceBlock","hasMatchingName","isMatch","getBlockTypesForPossibleFromTransforms","allBlockTypes","blockTypesWithPossibleFromTransforms","fromTransforms","getBlockTransforms","findTransform","getBlockTypesForPossibleToTransforms","transformsTo","possibleTransforms","blockNames","transformation","getPossibleBlockTransformations","blockTypesForFromTransforms","blockTypesForToTransforms","transforms","predicate","hooks","i","candidate","addFilter","toString","priority","applyFilters","blockTypeOrName","blockName","switchToBlockType","blocksArray","firstBlock","sourceName","transformationsFrom","transformationsTo","t","transformationResults","currentBlock","some","firstSwitchedBlock","index","transformedBlock"],"mappings":"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","sourcesContent":["/**\n * External dependencies\n */\nimport uuid from 'uuid/v4';\nimport {\n\tevery,\n\treduce,\n\tcastArray,\n\tfindIndex,\n\tisObjectLike,\n\tfilter,\n\tfirst,\n\tflatMap,\n\tuniq,\n\tisFunction,\n\tisEmpty,\n} from 'lodash';\n\n/**\n * WordPress dependencies\n */\nimport { createHooks, applyFilters } from '@wordpress/hooks';\n\n/**\n * Internal dependencies\n */\nimport { getBlockType, getBlockTypes } from './registration';\nimport { normalizeBlockType } from './utils';\n\n/**\n * Returns a block object given its type and attributes.\n *\n * @param {string} name        Block name.\n * @param {Object} attributes  Block attributes.\n * @param {?Array} innerBlocks Nested blocks.\n *\n * @return {Object} Block object.\n */\nexport function createBlock( name, attributes = {}, innerBlocks = [] ) {\n\t// Get the type definition associated with a registered block.\n\tconst blockType = getBlockType( name );\n\n\t// Ensure attributes contains only values defined by block type, and merge\n\t// default values for missing attributes.\n\tconst sanitizedAttributes = reduce( blockType.attributes, ( result, schema, key ) => {\n\t\tconst value = attributes[ key ];\n\n\t\tif ( undefined !== value ) {\n\t\t\tresult[ key ] = value;\n\t\t} else if ( schema.hasOwnProperty( 'default' ) ) {\n\t\t\tresult[ key ] = schema.default;\n\t\t}\n\n\t\tif ( [ 'node', 'children' ].indexOf( schema.source ) !== -1 ) {\n\t\t\t// Ensure value passed is always an array, which we're expecting in\n\t\t\t// the RichText component to handle the deprecated value.\n\t\t\tif ( typeof result[ key ] === 'string' ) {\n\t\t\t\tresult[ key ] = [ result[ key ] ];\n\t\t\t} else if ( ! Array.isArray( result[ key ] ) ) {\n\t\t\t\tresult[ key ] = [];\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}, {} );\n\n\tconst clientId = uuid();\n\n\t// Blocks are stored with a unique ID, the assigned type name, the block\n\t// attributes, and their inner blocks.\n\treturn {\n\t\tclientId,\n\t\tname,\n\t\tisValid: true,\n\t\tattributes: sanitizedAttributes,\n\t\tinnerBlocks,\n\t};\n}\n\n/**\n * Given a block object, returns a copy of the block object, optionally merging\n * new attributes and/or replacing its inner blocks.\n *\n * @param {Object} block              Block instance.\n * @param {Object} mergeAttributes    Block attributes.\n * @param {?Array} newInnerBlocks     Nested blocks.\n *\n * @return {Object} A cloned block.\n */\nexport function cloneBlock( block, mergeAttributes = {}, newInnerBlocks ) {\n\tconst clientId = uuid();\n\n\treturn {\n\t\t...block,\n\t\tclientId,\n\t\tattributes: {\n\t\t\t...block.attributes,\n\t\t\t...mergeAttributes,\n\t\t},\n\t\tinnerBlocks: newInnerBlocks ||\n\t\t\tblock.innerBlocks.map( ( innerBlock ) => cloneBlock( innerBlock ) ),\n\t};\n}\n\n/**\n * Returns a boolean indicating whether a transform is possible based on\n * various bits of context.\n *\n * @param {Object} transform The transform object to validate.\n * @param {string} direction Is this a 'from' or 'to' transform.\n * @param {Array} blocks The blocks to transform from.\n *\n * @return {boolean} Is the transform possible?\n */\nconst isPossibleTransformForSource = ( transform, direction, blocks ) => {\n\tif ( isEmpty( blocks ) ) {\n\t\treturn false;\n\t}\n\n\t// If multiple blocks are selected, only multi block transforms are allowed.\n\tconst isMultiBlock = blocks.length > 1;\n\tconst isValidForMultiBlocks = ! isMultiBlock || transform.isMultiBlock;\n\tif ( ! isValidForMultiBlocks ) {\n\t\treturn false;\n\t}\n\n\t// Only consider 'block' type transforms as valid.\n\tconst isBlockType = transform.type === 'block';\n\tif ( ! isBlockType ) {\n\t\treturn false;\n\t}\n\n\t// Check if the transform's block name matches the source block only if this is a transform 'from'.\n\tconst sourceBlock = first( blocks );\n\tconst hasMatchingName = direction !== 'from' || transform.blocks.indexOf( sourceBlock.name ) !== -1;\n\tif ( ! hasMatchingName ) {\n\t\treturn false;\n\t}\n\n\t// If the transform has a `isMatch` function specified, check that it returns true.\n\tif ( isFunction( transform.isMatch ) ) {\n\t\tconst attributes = transform.isMultiBlock ? blocks.map( ( block ) => block.attributes ) : sourceBlock.attributes;\n\t\tif ( ! transform.isMatch( attributes ) ) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n};\n\n/**\n * Returns block types that the 'blocks' can be transformed into, based on\n * 'from' transforms on other blocks.\n *\n * @param {Array}  blocks  The blocks to transform from.\n *\n * @return {Array} Block types that the blocks can be transformed into.\n */\nconst getBlockTypesForPossibleFromTransforms = ( blocks ) => {\n\tif ( isEmpty( blocks ) ) {\n\t\treturn [];\n\t}\n\n\tconst allBlockTypes = getBlockTypes();\n\n\t// filter all blocks to find those with a 'from' transform.\n\tconst blockTypesWithPossibleFromTransforms = filter(\n\t\tallBlockTypes,\n\t\t( blockType ) => {\n\t\t\tconst fromTransforms = getBlockTransforms( 'from', blockType.name );\n\n\t\t\treturn !! findTransform(\n\t\t\t\tfromTransforms,\n\t\t\t\t( transform ) => isPossibleTransformForSource( transform, 'from', blocks )\n\t\t\t);\n\t\t},\n\t);\n\n\treturn blockTypesWithPossibleFromTransforms;\n};\n\n/**\n * Returns block types that the 'blocks' can be transformed into, based on\n * the source block's own 'to' transforms.\n *\n * @param {Array} blocks The blocks to transform from.\n *\n * @return {Array} Block types that the source can be transformed into.\n */\nconst getBlockTypesForPossibleToTransforms = ( blocks ) => {\n\tif ( isEmpty( blocks ) ) {\n\t\treturn [];\n\t}\n\n\tconst sourceBlock = first( blocks );\n\tconst blockType = getBlockType( sourceBlock.name );\n\tconst transformsTo = getBlockTransforms( 'to', blockType.name );\n\n\t// filter all 'to' transforms to find those that are possible.\n\tconst possibleTransforms = filter(\n\t\ttransformsTo,\n\t\t( transform ) => isPossibleTransformForSource( transform, 'to', blocks )\n\t);\n\n\t// Build a list of block names using the possible 'to' transforms.\n\tconst blockNames = flatMap(\n\t\tpossibleTransforms,\n\t\t( transformation ) => transformation.blocks\n\t);\n\n\t// Map block names to block types.\n\treturn blockNames.map( ( name ) => getBlockType( name ) );\n};\n\n/**\n * Returns an array of block types that the set of blocks received as argument\n * can be transformed into.\n *\n * @param {Array} blocks Blocks array.\n *\n * @return {Array} Block types that the blocks argument can be transformed to.\n */\nexport function getPossibleBlockTransformations( blocks ) {\n\tif ( isEmpty( blocks ) ) {\n\t\treturn [];\n\t}\n\n\tconst sourceBlock = first( blocks );\n\tconst isMultiBlock = blocks.length > 1;\n\tif ( isMultiBlock && ! every( blocks, { name: sourceBlock.name } ) ) {\n\t\treturn [];\n\t}\n\n\tconst blockTypesForFromTransforms = getBlockTypesForPossibleFromTransforms( blocks );\n\tconst blockTypesForToTransforms = getBlockTypesForPossibleToTransforms( blocks );\n\n\treturn uniq( [\n\t\t...blockTypesForFromTransforms,\n\t\t...blockTypesForToTransforms,\n\t] );\n}\n\n/**\n * Given an array of transforms, returns the highest-priority transform where\n * the predicate function returns a truthy value. A higher-priority transform\n * is one with a lower priority value (i.e. first in priority order). Returns\n * null if the transforms set is empty or the predicate function returns a\n * falsey value for all entries.\n *\n * @param {Object[]} transforms Transforms to search.\n * @param {Function} predicate  Function returning true on matching transform.\n *\n * @return {?Object} Highest-priority transform candidate.\n */\nexport function findTransform( transforms, predicate ) {\n\t// The hooks library already has built-in mechanisms for managing priority\n\t// queue, so leverage via locally-defined instance.\n\tconst hooks = createHooks();\n\n\tfor ( let i = 0; i < transforms.length; i++ ) {\n\t\tconst candidate = transforms[ i ];\n\t\tif ( predicate( candidate ) ) {\n\t\t\thooks.addFilter(\n\t\t\t\t'transform',\n\t\t\t\t'transform/' + i.toString(),\n\t\t\t\t( result ) => result ? result : candidate,\n\t\t\t\tcandidate.priority\n\t\t\t);\n\t\t}\n\t}\n\n\t// Filter name is arbitrarily chosen but consistent with above aggregation.\n\treturn hooks.applyFilters( 'transform', null );\n}\n\n/**\n * Returns normal block transforms for a given transform direction, optionally\n * for a specific block by name, or an empty array if there are no transforms.\n * If no block name is provided, returns transforms for all blocks. A normal\n * transform object includes `blockName` as a property.\n *\n * @param {string}  direction Transform direction (\"to\", \"from\").\n * @param {string|Object} blockTypeOrName  Block type or name.\n *\n * @return {Array} Block transforms for direction.\n */\nexport function getBlockTransforms( direction, blockTypeOrName ) {\n\t// When retrieving transforms for all block types, recurse into self.\n\tif ( blockTypeOrName === undefined ) {\n\t\treturn flatMap(\n\t\t\tgetBlockTypes(),\n\t\t\t( { name } ) => getBlockTransforms( direction, name )\n\t\t);\n\t}\n\n\t// Validate that block type exists and has array of direction.\n\tconst blockType = normalizeBlockType( blockTypeOrName );\n\tconst { name: blockName, transforms } = blockType || {};\n\tif ( ! transforms || ! Array.isArray( transforms[ direction ] ) ) {\n\t\treturn [];\n\t}\n\n\t// Map transforms to normal form.\n\treturn transforms[ direction ].map( ( transform ) => ( {\n\t\t...transform,\n\t\tblockName,\n\t} ) );\n}\n\n/**\n * Switch one or more blocks into one or more blocks of the new block type.\n *\n * @param {Array|Object} blocks Blocks array or block object.\n * @param {string}       name   Block name.\n *\n * @return {Array} Array of blocks.\n */\nexport function switchToBlockType( blocks, name ) {\n\tconst blocksArray = castArray( blocks );\n\tconst isMultiBlock = blocksArray.length > 1;\n\tconst firstBlock = blocksArray[ 0 ];\n\tconst sourceName = firstBlock.name;\n\n\tif ( isMultiBlock && ! every( blocksArray, ( block ) => ( block.name === sourceName ) ) ) {\n\t\treturn null;\n\t}\n\n\t// Find the right transformation by giving priority to the \"to\"\n\t// transformation.\n\tconst transformationsFrom = getBlockTransforms( 'from', name );\n\tconst transformationsTo = getBlockTransforms( 'to', sourceName );\n\tconst transformation =\n\t\tfindTransform(\n\t\t\ttransformationsTo,\n\t\t\t( t ) => t.type === 'block' && t.blocks.indexOf( name ) !== -1 && ( ! isMultiBlock || t.isMultiBlock )\n\t\t) ||\n\t\tfindTransform(\n\t\t\ttransformationsFrom,\n\t\t\t( t ) => t.type === 'block' && t.blocks.indexOf( sourceName ) !== -1 && ( ! isMultiBlock || t.isMultiBlock )\n\t\t);\n\n\t// Stop if there is no valid transformation.\n\tif ( ! transformation ) {\n\t\treturn null;\n\t}\n\n\tlet transformationResults;\n\tif ( transformation.isMultiBlock ) {\n\t\ttransformationResults = transformation.transform( blocksArray.map( ( currentBlock ) => currentBlock.attributes ) );\n\t} else {\n\t\ttransformationResults = transformation.transform( firstBlock.attributes );\n\t}\n\n\t// Ensure that the transformation function returned an object or an array\n\t// of objects.\n\tif ( ! isObjectLike( transformationResults ) ) {\n\t\treturn null;\n\t}\n\n\t// If the transformation function returned a single object, we want to work\n\t// with an array instead.\n\ttransformationResults = castArray( transformationResults );\n\n\t// Ensure that every block object returned by the transformation has a\n\t// valid block type.\n\tif ( transformationResults.some( ( result ) => ! getBlockType( result.name ) ) ) {\n\t\treturn null;\n\t}\n\n\tconst firstSwitchedBlock = findIndex( transformationResults, ( result ) => result.name === name );\n\n\t// Ensure that at least one block object returned by the transformation has\n\t// the expected \"destination\" block type.\n\tif ( firstSwitchedBlock < 0 ) {\n\t\treturn null;\n\t}\n\n\treturn transformationResults.map( ( result, index ) => {\n\t\tconst transformedBlock = {\n\t\t\t...result,\n\t\t\t// The first transformed block whose type matches the \"destination\"\n\t\t\t// type gets to keep the existing client ID of the first block.\n\t\t\tclientId: index === firstSwitchedBlock ? firstBlock.clientId : result.clientId,\n\t\t};\n\n\t\t/**\n\t\t * Filters an individual transform result from block transformation.\n\t\t * All of the original blocks are passed, since transformations are\n\t\t * many-to-many, not one-to-one.\n\t\t *\n\t\t * @param {Object}   transformedBlock The transformed block.\n\t\t * @param {Object[]} blocks           Original blocks transformed.\n\t\t */\n\t\treturn applyFilters( 'blocks.switchToBlockType.transformedBlock', transformedBlock, blocks );\n\t} );\n}\n"]}