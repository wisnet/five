{"version":3,"sources":["/Users/riad/Workspace/a8c/gutenberg/packages/url/src/index.js"],"names":["URL_REGEXP","EMAIL_REGEXP","USABLE_HREF_REGEXP","isURL","url","test","getProtocol","matches","exec","isValidProtocol","protocol","getAuthority","isValidAuthority","authority","getPath","isValidPath","path","getQueryString","isValidQueryString","queryString","getFragment","isValidFragment","fragment","addQueryArgs","args","baseUrl","queryStringIndex","indexOf","Object","assign","substr","getQueryArg","arg","query","hasQueryArg","undefined","removeQueryArgs","forEach","prependHTTP","safeDecodeURI","uri","decodeURI","uriError","filterURLForDisplay","filteredURL","replace","match"],"mappings":"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","sourcesContent":["/**\n * External dependencies\n */\nimport { parse, stringify } from 'qs';\n\nconst URL_REGEXP = /^(?:https?:)?\\/\\/\\S+$/i;\nconst EMAIL_REGEXP = /^(mailto:)?[a-z0-9._%+-]+@[a-z0-9][a-z0-9.-]*\\.[a-z]{2,63}$/i;\nconst USABLE_HREF_REGEXP = /^(?:[a-z]+:|#|\\?|\\.|\\/)/i;\n\n/**\n * Determines whether the given string looks like a URL.\n *\n * @param {string} url The string to scrutinise.\n *\n * @return {boolean} Whether or not it looks like a URL.\n */\nexport function isURL( url ) {\n\treturn URL_REGEXP.test( url );\n}\n\n/**\n * Returns the protocol part of the URL.\n *\n * @param {string} url The full URL.\n *\n * @return {?string} The protocol part of the URL.\n */\nexport function getProtocol( url ) {\n\tconst matches = /^([^\\s:]+:)/.exec( url );\n\tif ( matches ) {\n\t\treturn matches[ 1 ];\n\t}\n}\n\n/**\n * Tests if a url protocol is valid.\n *\n * @param {string} protocol The url protocol.\n *\n * @return {boolean} True if the argument is a valid protocol (e.g. http:, tel:).\n */\nexport function isValidProtocol( protocol ) {\n\tif ( ! protocol ) {\n\t\treturn false;\n\t}\n\treturn /^[a-z\\-.\\+]+[0-9]*:$/i.test( protocol );\n}\n\n/**\n * Returns the authority part of the URL.\n *\n * @param {string} url The full URL.\n *\n * @return {?string} The authority part of the URL.\n */\nexport function getAuthority( url ) {\n\tconst matches = /^[^\\/\\s:]+:(?:\\/\\/)?\\/?([^\\/\\s#?]+)[\\/#?]{0,1}\\S*$/.exec( url );\n\tif ( matches ) {\n\t\treturn matches[ 1 ];\n\t}\n}\n\n/**\n * Checks for invalid characters within the provided authority.\n *\n * @param {string} authority A string containing the URL authority.\n *\n * @return {boolean} True if the argument contains a valid authority.\n */\nexport function isValidAuthority( authority ) {\n\tif ( ! authority ) {\n\t\treturn false;\n\t}\n\treturn /^[^\\s#?]+$/.test( authority );\n}\n\n/**\n * Returns the path part of the URL.\n *\n * @param {string} url The full URL.\n *\n * @return {?string} The path part of the URL.\n */\nexport function getPath( url ) {\n\tconst matches = /^[^\\/\\s:]+:(?:\\/\\/)?[^\\/\\s#?]+[\\/]([^\\s#?]+)[#?]{0,1}\\S*$/.exec( url );\n\tif ( matches ) {\n\t\treturn matches[ 1 ];\n\t}\n}\n\n/**\n * Checks for invalid characters within the provided path.\n *\n * @param {string} path The URL path.\n *\n * @return {boolean} True if the argument contains a valid path\n */\nexport function isValidPath( path ) {\n\tif ( ! path ) {\n\t\treturn false;\n\t}\n\treturn /^[^\\s#?]+$/.test( path );\n}\n\n/**\n * Returns the query string part of the URL.\n *\n * @param {string} url The full URL.\n *\n * @return {?string} The query string part of the URL.\n */\nexport function getQueryString( url ) {\n\tconst matches = /^\\S+?\\?([^\\s#]+)/.exec( url );\n\tif ( matches ) {\n\t\treturn matches[ 1 ];\n\t}\n}\n\n/**\n * Checks for invalid characters within the provided query string.\n *\n * @param {string} queryString The query string.\n *\n * @return {boolean} True if the argument contains a valid query string.\n */\nexport function isValidQueryString( queryString ) {\n\tif ( ! queryString ) {\n\t\treturn false;\n\t}\n\treturn /^[^\\s#?\\/]+$/.test( queryString );\n}\n\n/**\n * Returns the fragment part of the URL.\n *\n * @param {string} url The full URL\n *\n * @return {?string} The fragment part of the URL.\n */\nexport function getFragment( url ) {\n\tconst matches = /^\\S+?(#[^\\s\\?]*)/.exec( url );\n\tif ( matches ) {\n\t\treturn matches[ 1 ];\n\t}\n}\n\n/**\n * Checks for invalid characters within the provided fragment.\n *\n * @param {string} fragment The url fragment.\n *\n * @return {boolean} True if the argument contains a valid fragment.\n */\nexport function isValidFragment( fragment ) {\n\tif ( ! fragment ) {\n\t\treturn false;\n\t}\n\treturn /^#[^\\s#?\\/]*$/.test( fragment );\n}\n\n/**\n * Appends arguments as querystring to the provided URL. If the URL already\n * includes query arguments, the arguments are merged with (and take precedent\n * over) the existing set.\n *\n * @param {?string} url  URL to which arguments should be appended. If omitted,\n *                       only the resulting querystring is returned.\n * @param {Object}  args Query arguments to apply to URL.\n *\n * @return {string} URL with arguments applied.\n */\nexport function addQueryArgs( url = '', args ) {\n\tlet baseUrl = url;\n\n\t// Determine whether URL already had query arguments.\n\tconst queryStringIndex = url.indexOf( '?' );\n\tif ( queryStringIndex !== -1 ) {\n\t\t// Merge into existing query arguments.\n\t\targs = Object.assign(\n\t\t\tparse( url.substr( queryStringIndex + 1 ) ),\n\t\t\targs\n\t\t);\n\n\t\t// Change working base URL to omit previous query arguments.\n\t\tbaseUrl = baseUrl.substr( 0, queryStringIndex );\n\t}\n\n\treturn baseUrl + '?' + stringify( args );\n}\n\n/**\n * Returns a single query argument of the url\n *\n * @param {string} url URL\n * @param {string} arg Query arg name\n *\n * @return {Array|string} Query arg value.\n */\nexport function getQueryArg( url, arg ) {\n\tconst queryStringIndex = url.indexOf( '?' );\n\tconst query = queryStringIndex !== -1 ? parse( url.substr( queryStringIndex + 1 ) ) : {};\n\n\treturn query[ arg ];\n}\n\n/**\n * Determines whether the URL contains a given query arg.\n *\n * @param {string} url URL\n * @param {string} arg Query arg name\n *\n * @return {boolean} Whether or not the URL contains the query aeg.\n */\nexport function hasQueryArg( url, arg ) {\n\treturn getQueryArg( url, arg ) !== undefined;\n}\n\n/**\n * Removes arguments from the query string of the url\n *\n * @param {string} url  URL\n * @param {...string} args Query Args\n *\n * @return {string} Updated URL\n */\nexport function removeQueryArgs( url, ...args ) {\n\tconst queryStringIndex = url.indexOf( '?' );\n\tconst query = queryStringIndex !== -1 ? parse( url.substr( queryStringIndex + 1 ) ) : {};\n\tconst baseUrl = queryStringIndex !== -1 ? url.substr( 0, queryStringIndex ) : url;\n\n\targs.forEach( ( arg ) => delete query[ arg ] );\n\n\treturn baseUrl + '?' + stringify( query );\n}\n\n/**\n * Prepends \"http://\" to a url, if it looks like something that is meant to be a TLD.\n *\n * @param  {string} url The URL to test\n *\n * @return {string}     The updated URL\n */\nexport function prependHTTP( url ) {\n\tif ( ! USABLE_HREF_REGEXP.test( url ) && ! EMAIL_REGEXP.test( url ) ) {\n\t\treturn 'http://' + url;\n\t}\n\n\treturn url;\n}\n\n/**\n * Safely decodes a URI with `decodeURI`. Returns the URI unmodified if\n * `decodeURI` throws an error.\n *\n * @param {string} uri URI to decode.\n *\n * @return {string} Decoded URI if possible.\n */\nexport function safeDecodeURI( uri ) {\n\ttry {\n\t\treturn decodeURI( uri );\n\t} catch ( uriError ) {\n\t\treturn uri;\n\t}\n}\n\n/**\n * Returns a URL for display.\n *\n * @param {string} url Original URL.\n *\n * @return {string} Displayed URL.\n */\nexport function filterURLForDisplay( url ) {\n\t// Remove protocol and www prefixes.\n\tconst filteredURL = url.replace( /^(?:https?:)\\/\\/(?:www\\.)?/, '' );\n\n\t// Ends with / and only has that single slash, strip it.\n\tif ( filteredURL.match( /^[^\\/]+\\/$/ ) ) {\n\t\treturn filteredURL.replace( '/', '' );\n\t}\n\n\treturn filteredURL;\n}\n"]}