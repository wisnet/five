{"version":3,"sources":["/Users/riad/Workspace/a8c/gutenberg/packages/rich-text/src/apply-format.js"],"names":["applyFormat","format","formats","text","start","end","startIndex","endIndex","newFormats","slice","startFormat","type","applyFormats","previousFormat","hasType","formatPlaceholder","index","undefined","newFormatsAtIndex","filter","push"],"mappings":";;;;;;;AAIA;;AAMA;;AAVA;;;;AAMA;;;;AAMA;;;;;;;;;;;;AAYO,SAASA,WAAT,OAENC,MAFM,EAKL;AAAA,MAJCC,OAID,QAJCA,OAID;AAAA,MAJUC,IAIV,QAJUA,IAIV;AAAA,MAJgBC,KAIhB,QAJgBA,KAIhB;AAAA,MAJuBC,GAIvB,QAJuBA,GAIvB;AAAA,MAFDC,UAEC,uEAFYF,KAEZ;AAAA,MADDG,QACC,uEADUF,GACV;AACD,MAAMG,UAAU,GAAGN,OAAO,CAACO,KAAR,CAAe,CAAf,CAAnB,CADC,CAGD;;AACA,MAAKH,UAAU,KAAKC,QAApB,EAA+B;AAC9B,QAAMG,WAAW,GAAG,kBAAMF,UAAU,CAAEF,UAAF,CAAhB,EAAgC;AAAEK,MAAAA,IAAI,EAAEV,MAAM,CAACU;AAAf,KAAhC,CAApB,CAD8B,CAG9B;AACA;;AACA,QAAKD,WAAL,EAAmB;AAClB,aAAQ,kBAAMF,UAAU,CAAEF,UAAF,CAAhB,EAAgCI,WAAhC,CAAR,EAAwD;AACvDE,QAAAA,YAAY,CAAEJ,UAAF,EAAcF,UAAd,EAA0BL,MAA1B,CAAZ;AACAK,QAAAA,UAAU;AACV;;AAEDC,MAAAA,QAAQ;;AAER,aAAQ,kBAAMC,UAAU,CAAED,QAAF,CAAhB,EAA8BG,WAA9B,CAAR,EAAsD;AACrDE,QAAAA,YAAY,CAAEJ,UAAF,EAAcD,QAAd,EAAwBN,MAAxB,CAAZ;AACAM,QAAAA,QAAQ;AACR,OAXiB,CAYnB;AACA;;AACC,KAdD,MAcO;AACN,UAAMM,cAAc,GAAGL,UAAU,CAAEF,UAAU,GAAG,CAAf,CAAV,IAAgC,EAAvD;AACA,UAAMQ,OAAO,GAAG,kBAAMD,cAAN,EAAsB;AAAEF,QAAAA,IAAI,EAAEV,MAAM,CAACU;AAAf,OAAtB,CAAhB;AAEA,aAAO;AACNT,QAAAA,OAAO,EAAPA,OADM;AAENC,QAAAA,IAAI,EAAJA,IAFM;AAGNC,QAAAA,KAAK,EAALA,KAHM;AAINC,QAAAA,GAAG,EAAHA,GAJM;AAKNU,QAAAA,iBAAiB,EAAE;AAClBC,UAAAA,KAAK,EAAEV,UADW;AAElBL,UAAAA,MAAM,EAAEa,OAAO,GAAGG,SAAH,GAAehB;AAFZ;AALb,OAAP;AAUA;AACD,GAlCD,MAkCO;AACN,SAAM,IAAIe,KAAK,GAAGV,UAAlB,EAA8BU,KAAK,GAAGT,QAAtC,EAAgDS,KAAK,EAArD,EAA0D;AACzDJ,MAAAA,YAAY,CAAEJ,UAAF,EAAcQ,KAAd,EAAqBf,MAArB,CAAZ;AACA;AACD;;AAED,SAAO,wCAAkB;AAAEC,IAAAA,OAAO,EAAEM,UAAX;AAAuBL,IAAAA,IAAI,EAAJA,IAAvB;AAA6BC,IAAAA,KAAK,EAALA,KAA7B;AAAoCC,IAAAA,GAAG,EAAHA;AAApC,GAAlB,CAAP;AACA;;AAED,SAASO,YAAT,CAAuBV,OAAvB,EAAgCc,KAAhC,EAAuCf,MAAvC,EAAgD;AAC/C,MAAKC,OAAO,CAAEc,KAAF,CAAZ,EAAwB;AACvB,QAAME,iBAAiB,GAAGhB,OAAO,CAAEc,KAAF,CAAP,CAAiBG,MAAjB,CAAyB;AAAA,UAAIR,IAAJ,SAAIA,IAAJ;AAAA,aAAgBA,IAAI,KAAKV,MAAM,CAACU,IAAhC;AAAA,KAAzB,CAA1B;AACAO,IAAAA,iBAAiB,CAACE,IAAlB,CAAwBnB,MAAxB;AACAC,IAAAA,OAAO,CAAEc,KAAF,CAAP,GAAmBE,iBAAnB;AACA,GAJD,MAIO;AACNhB,IAAAA,OAAO,CAAEc,KAAF,CAAP,GAAmB,CAAEf,MAAF,CAAnB;AACA;AACD","sourcesContent":["/**\n * External dependencies\n */\n\nimport { find } from 'lodash';\n\n/**\n * Internal dependencies\n */\n\nimport { normaliseFormats } from './normalise-formats';\n\n/**\n * Apply a format object to a Rich Text value from the given `startIndex` to the\n * given `endIndex`. Indices are retrieved from the selection if none are\n * provided.\n *\n * @param {Object} value      Value to modify.\n * @param {Object} format     Format to apply.\n * @param {number} startIndex Start index.\n * @param {number} endIndex   End index.\n *\n * @return {Object} A new value with the format applied.\n */\nexport function applyFormat(\n\t{ formats, text, start, end },\n\tformat,\n\tstartIndex = start,\n\tendIndex = end\n) {\n\tconst newFormats = formats.slice( 0 );\n\n\t// The selection is collpased.\n\tif ( startIndex === endIndex ) {\n\t\tconst startFormat = find( newFormats[ startIndex ], { type: format.type } );\n\n\t\t// If the caret is at a format of the same type, expand start and end to\n\t\t// the edges of the format. This is useful to apply new attributes.\n\t\tif ( startFormat ) {\n\t\t\twhile ( find( newFormats[ startIndex ], startFormat ) ) {\n\t\t\t\tapplyFormats( newFormats, startIndex, format );\n\t\t\t\tstartIndex--;\n\t\t\t}\n\n\t\t\tendIndex++;\n\n\t\t\twhile ( find( newFormats[ endIndex ], startFormat ) ) {\n\t\t\t\tapplyFormats( newFormats, endIndex, format );\n\t\t\t\tendIndex++;\n\t\t\t}\n\t\t// Otherwise, insert a placeholder with the format so new input appears\n\t\t// with the format applied.\n\t\t} else {\n\t\t\tconst previousFormat = newFormats[ startIndex - 1 ] || [];\n\t\t\tconst hasType = find( previousFormat, { type: format.type } );\n\n\t\t\treturn {\n\t\t\t\tformats,\n\t\t\t\ttext,\n\t\t\t\tstart,\n\t\t\t\tend,\n\t\t\t\tformatPlaceholder: {\n\t\t\t\t\tindex: startIndex,\n\t\t\t\t\tformat: hasType ? undefined : format,\n\t\t\t\t},\n\t\t\t};\n\t\t}\n\t} else {\n\t\tfor ( let index = startIndex; index < endIndex; index++ ) {\n\t\t\tapplyFormats( newFormats, index, format );\n\t\t}\n\t}\n\n\treturn normaliseFormats( { formats: newFormats, text, start, end } );\n}\n\nfunction applyFormats( formats, index, format ) {\n\tif ( formats[ index ] ) {\n\t\tconst newFormatsAtIndex = formats[ index ].filter( ( { type } ) => type !== format.type );\n\t\tnewFormatsAtIndex.push( format );\n\t\tformats[ index ] = newFormatsAtIndex;\n\t} else {\n\t\tformats[ index ] = [ format ];\n\t}\n}\n"]}