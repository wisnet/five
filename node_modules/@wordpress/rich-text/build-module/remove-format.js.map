{"version":3,"sources":["/Users/riad/Workspace/a8c/gutenberg/packages/rich-text/src/remove-format.js"],"names":["find","normaliseFormats","removeFormat","formatType","formats","text","start","end","startIndex","endIndex","newFormats","slice","format","type","filterFormats","i","index","filter","length"],"mappings":"AAAA;;;AAIA,SAASA,IAAT,QAAqB,QAArB;AAEA;;;;AAIA,SAASC,gBAAT,QAAiC,qBAAjC;AAEA;;;;;;;;;;;;;AAYA,OAAO,SAASC,YAAT,OAENC,UAFM,EAKL;AAAA,MAJCC,OAID,QAJCA,OAID;AAAA,MAJUC,IAIV,QAJUA,IAIV;AAAA,MAJgBC,KAIhB,QAJgBA,KAIhB;AAAA,MAJuBC,GAIvB,QAJuBA,GAIvB;AAAA,MAFDC,UAEC,uEAFYF,KAEZ;AAAA,MADDG,QACC,uEADUF,GACV;AACD,MAAMG,UAAU,GAAGN,OAAO,CAACO,KAAR,CAAe,CAAf,CAAnB,CADC,CAGD;AACA;;AACA,MAAKH,UAAU,KAAKC,QAApB,EAA+B;AAC9B,QAAMG,MAAM,GAAGZ,IAAI,CAAEU,UAAU,CAAEF,UAAF,CAAZ,EAA4B;AAAEK,MAAAA,IAAI,EAAEV;AAAR,KAA5B,CAAnB;;AAEA,WAAQH,IAAI,CAAEU,UAAU,CAAEF,UAAF,CAAZ,EAA4BI,MAA5B,CAAZ,EAAmD;AAClDE,MAAAA,aAAa,CAAEJ,UAAF,EAAcF,UAAd,EAA0BL,UAA1B,CAAb;AACAK,MAAAA,UAAU;AACV;;AAEDC,IAAAA,QAAQ;;AAER,WAAQT,IAAI,CAAEU,UAAU,CAAED,QAAF,CAAZ,EAA0BG,MAA1B,CAAZ,EAAiD;AAChDE,MAAAA,aAAa,CAAEJ,UAAF,EAAcD,QAAd,EAAwBN,UAAxB,CAAb;AACAM,MAAAA,QAAQ;AACR;AACD,GAdD,MAcO;AACN,SAAM,IAAIM,CAAC,GAAGP,UAAd,EAA0BO,CAAC,GAAGN,QAA9B,EAAwCM,CAAC,EAAzC,EAA8C;AAC7C,UAAKL,UAAU,CAAEK,CAAF,CAAf,EAAuB;AACtBD,QAAAA,aAAa,CAAEJ,UAAF,EAAcK,CAAd,EAAiBZ,UAAjB,CAAb;AACA;AACD;AACD;;AAED,SAAOF,gBAAgB,CAAE;AAAEG,IAAAA,OAAO,EAAEM,UAAX;AAAuBL,IAAAA,IAAI,EAAJA,IAAvB;AAA6BC,IAAAA,KAAK,EAALA,KAA7B;AAAoCC,IAAAA,GAAG,EAAHA;AAApC,GAAF,CAAvB;AACA;;AAED,SAASO,aAAT,CAAwBV,OAAxB,EAAiCY,KAAjC,EAAwCb,UAAxC,EAAqD;AACpD,MAAMO,UAAU,GAAGN,OAAO,CAAEY,KAAF,CAAP,CAAiBC,MAAjB,CAAyB;AAAA,QAAIJ,IAAJ,SAAIA,IAAJ;AAAA,WAAgBA,IAAI,KAAKV,UAAzB;AAAA,GAAzB,CAAnB;;AAEA,MAAKO,UAAU,CAACQ,MAAhB,EAAyB;AACxBd,IAAAA,OAAO,CAAEY,KAAF,CAAP,GAAmBN,UAAnB;AACA,GAFD,MAEO;AACN,WAAON,OAAO,CAAEY,KAAF,CAAd;AACA;AACD","sourcesContent":["/**\n * External dependencies\n */\n\nimport { find } from 'lodash';\n\n/**\n * Internal dependencies\n */\n\nimport { normaliseFormats } from './normalise-formats';\n\n/**\n * Remove any format object from a Rich Text value by type from the given\n * `startIndex` to the given `endIndex`. Indices are retrieved from the\n * selection if none are provided.\n *\n * @param {Object} value      Value to modify.\n * @param {string} formatType Format type to remove.\n * @param {number} startIndex Start index.\n * @param {number} endIndex   End index.\n *\n * @return {Object} A new value with the format applied.\n */\nexport function removeFormat(\n\t{ formats, text, start, end },\n\tformatType,\n\tstartIndex = start,\n\tendIndex = end\n) {\n\tconst newFormats = formats.slice( 0 );\n\n\t// If the selection is collapsed, expand start and end to the edges of the\n\t// format.\n\tif ( startIndex === endIndex ) {\n\t\tconst format = find( newFormats[ startIndex ], { type: formatType } );\n\n\t\twhile ( find( newFormats[ startIndex ], format ) ) {\n\t\t\tfilterFormats( newFormats, startIndex, formatType );\n\t\t\tstartIndex--;\n\t\t}\n\n\t\tendIndex++;\n\n\t\twhile ( find( newFormats[ endIndex ], format ) ) {\n\t\t\tfilterFormats( newFormats, endIndex, formatType );\n\t\t\tendIndex++;\n\t\t}\n\t} else {\n\t\tfor ( let i = startIndex; i < endIndex; i++ ) {\n\t\t\tif ( newFormats[ i ] ) {\n\t\t\t\tfilterFormats( newFormats, i, formatType );\n\t\t\t}\n\t\t}\n\t}\n\n\treturn normaliseFormats( { formats: newFormats, text, start, end } );\n}\n\nfunction filterFormats( formats, index, formatType ) {\n\tconst newFormats = formats[ index ].filter( ( { type } ) => type !== formatType );\n\n\tif ( newFormats.length ) {\n\t\tformats[ index ] = newFormats;\n\t} else {\n\t\tdelete formats[ index ];\n\t}\n}\n"]}