{"version":3,"sources":["/Users/riad/Workspace/a8c/gutenberg/packages/rich-text/src/to-dom.js"],"names":["window","Node","TEXT_NODE","ELEMENT_NODE","createPathToNode","node","rootNode","path","parentNode","i","previousSibling","getNodeByPath","length","childNodes","shift","offset","createEmpty","document","append","element","child","ownerDocument","createTextNode","type","attributes","createElement","key","setAttribute","appendChild","appendText","text","appendData","getLastChild","lastChild","getParent","isText","nodeType","getText","nodeValue","remove","removeChild","padEmptyLines","createLinePadding","multilineWrapperTags","doc","index","indexOf","nodeName","toLowerCase","insertBefore","prepareFormats","prepareEditableTree","value","reduce","accumlator","fn","formats","toDom","multilineTag","startPath","endPath","tree","onStartIndex","body","pointer","onEndIndex","isEditableTree","selection","apply","current","applyValue","start","undefined","applySelection","future","futureChild","firstChild","currentChild","isEqualNode","replaceChild","isRangeEqual","a","b","startContainer","startOffset","endContainer","endOffset","windowSelection","getSelection","range","createRange","collapsed","insertData","setStart","setEnd","rangeCount","getRangeAt","removeAllRanges","addRange"],"mappings":"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","sourcesContent":["/**\n * Internal dependencies\n */\n\nimport { toTree } from './to-tree';\nimport { createElement } from './create-element';\n\n/**\n * Browser dependencies\n */\n\nconst { TEXT_NODE, ELEMENT_NODE } = window.Node;\n\n/**\n * Creates a path as an array of indices from the given root node to the given\n * node.\n *\n * @param {Node}        node     Node to find the path of.\n * @param {HTMLElement} rootNode Root node to find the path from.\n * @param {Array}       path     Initial path to build on.\n *\n * @return {Array} The path from the root node to the node.\n */\nfunction createPathToNode( node, rootNode, path ) {\n\tconst parentNode = node.parentNode;\n\tlet i = 0;\n\n\twhile ( ( node = node.previousSibling ) ) {\n\t\ti++;\n\t}\n\n\tpath = [ i, ...path ];\n\n\tif ( parentNode !== rootNode ) {\n\t\tpath = createPathToNode( parentNode, rootNode, path );\n\t}\n\n\treturn path;\n}\n\n/**\n * Gets a node given a path (array of indices) from the given node.\n *\n * @param {HTMLElement} node Root node to find the wanted node in.\n * @param {Array}       path Path (indices) to the wanted node.\n *\n * @return {Object} Object with the found node and the remaining offset (if any).\n */\nfunction getNodeByPath( node, path ) {\n\tpath = [ ...path ];\n\n\twhile ( node && path.length > 1 ) {\n\t\tnode = node.childNodes[ path.shift() ];\n\t}\n\n\treturn {\n\t\tnode,\n\t\toffset: path[ 0 ],\n\t};\n}\n\n/**\n * Returns a new instance of a DOM tree upon which RichText operations can be\n * applied.\n *\n * Note: The current implementation will return a shared reference, reset on\n * each call to `createEmpty`. Therefore, you should not hold a reference to\n * the value to operate upon asynchronously, as it may have unexpected results.\n *\n * @return {WPRichTextTree} RichText tree.\n */\nconst createEmpty = () => createElement( document, '' );\n\nfunction append( element, child ) {\n\tif ( typeof child === 'string' ) {\n\t\tchild = element.ownerDocument.createTextNode( child );\n\t}\n\n\tconst { type, attributes } = child;\n\n\tif ( type ) {\n\t\tchild = element.ownerDocument.createElement( type );\n\n\t\tfor ( const key in attributes ) {\n\t\t\tchild.setAttribute( key, attributes[ key ] );\n\t\t}\n\t}\n\n\treturn element.appendChild( child );\n}\n\nfunction appendText( node, text ) {\n\tnode.appendData( text );\n}\n\nfunction getLastChild( { lastChild } ) {\n\treturn lastChild;\n}\n\nfunction getParent( { parentNode } ) {\n\treturn parentNode;\n}\n\nfunction isText( { nodeType } ) {\n\treturn nodeType === TEXT_NODE;\n}\n\nfunction getText( { nodeValue } ) {\n\treturn nodeValue;\n}\n\nfunction remove( node ) {\n\treturn node.parentNode.removeChild( node );\n}\n\nfunction padEmptyLines( { element, createLinePadding, multilineWrapperTags } ) {\n\tconst length = element.childNodes.length;\n\tconst doc = element.ownerDocument;\n\n\tfor ( let index = 0; index < length; index++ ) {\n\t\tconst child = element.childNodes[ index ];\n\n\t\tif ( child.nodeType === TEXT_NODE ) {\n\t\t\tif ( length === 1 && ! child.nodeValue ) {\n\t\t\t\t// Pad if the only child is an empty text node.\n\t\t\t\telement.appendChild( createLinePadding( doc ) );\n\t\t\t}\n\t\t} else {\n\t\t\tif (\n\t\t\t\tmultilineWrapperTags &&\n\t\t\t\t! child.previousSibling &&\n\t\t\t\tmultilineWrapperTags.indexOf( child.nodeName.toLowerCase() ) !== -1\n\t\t\t) {\n\t\t\t\t// Pad the line if there is no content before a nested wrapper.\n\t\t\t\telement.insertBefore( createLinePadding( doc ), child );\n\t\t\t}\n\n\t\t\tpadEmptyLines( { element: child, createLinePadding, multilineWrapperTags } );\n\t\t}\n\t}\n}\n\nfunction prepareFormats( prepareEditableTree = [], value ) {\n\treturn prepareEditableTree.reduce( ( accumlator, fn ) => {\n\t\treturn fn( accumlator, value.text );\n\t}, value.formats );\n}\n\nexport function toDom( {\n\tvalue,\n\tmultilineTag,\n\tmultilineWrapperTags,\n\tcreateLinePadding,\n\tprepareEditableTree,\n} ) {\n\tlet startPath = [];\n\tlet endPath = [];\n\n\tconst tree = toTree( {\n\t\tvalue: {\n\t\t\t...value,\n\t\t\tformats: prepareFormats( prepareEditableTree, value ),\n\t\t},\n\t\tmultilineTag,\n\t\tmultilineWrapperTags,\n\t\tcreateEmpty,\n\t\tappend,\n\t\tgetLastChild,\n\t\tgetParent,\n\t\tisText,\n\t\tgetText,\n\t\tremove,\n\t\tappendText,\n\t\tonStartIndex( body, pointer ) {\n\t\t\tstartPath = createPathToNode( pointer, body, [ pointer.nodeValue.length ] );\n\t\t},\n\t\tonEndIndex( body, pointer ) {\n\t\t\tendPath = createPathToNode( pointer, body, [ pointer.nodeValue.length ] );\n\t\t},\n\t\tisEditableTree: true,\n\t} );\n\n\tif ( createLinePadding ) {\n\t\tpadEmptyLines( { element: tree, createLinePadding, multilineWrapperTags } );\n\t}\n\n\treturn {\n\t\tbody: tree,\n\t\tselection: { startPath, endPath },\n\t};\n}\n\n/**\n * Create an `Element` tree from a Rich Text value and applies the difference to\n * the `Element` tree contained by `current`. If a `multilineTag` is provided,\n * text separated by two new lines will be wrapped in an `Element` of that type.\n *\n * @param {Object}      value        Value to apply.\n * @param {HTMLElement} current      The live root node to apply the element\n *                                   tree to.\n * @param {string}      multilineTag Multiline tag.\n */\nexport function apply( {\n\tvalue,\n\tcurrent,\n\tmultilineTag,\n\tmultilineWrapperTags,\n\tcreateLinePadding,\n\tprepareEditableTree,\n} ) {\n\t// Construct a new element tree in memory.\n\tconst { body, selection } = toDom( {\n\t\tvalue,\n\t\tmultilineTag,\n\t\tmultilineWrapperTags,\n\t\tcreateLinePadding,\n\t\tprepareEditableTree,\n\t} );\n\n\tapplyValue( body, current );\n\n\tif ( value.start !== undefined ) {\n\t\tapplySelection( selection, current );\n\t}\n}\n\nexport function applyValue( future, current ) {\n\tlet i = 0;\n\tlet futureChild;\n\n\twhile ( ( futureChild = future.firstChild ) ) {\n\t\tconst currentChild = current.childNodes[ i ];\n\n\t\tif ( ! currentChild ) {\n\t\t\tcurrent.appendChild( futureChild );\n\t\t} else if ( ! currentChild.isEqualNode( futureChild ) ) {\n\t\t\tcurrent.replaceChild( futureChild, currentChild );\n\t\t} else {\n\t\t\tfuture.removeChild( futureChild );\n\t\t}\n\n\t\ti++;\n\t}\n\n\twhile ( current.childNodes[ i ] ) {\n\t\tcurrent.removeChild( current.childNodes[ i ] );\n\t}\n}\n\n/**\n * Returns true if two ranges are equal, or false otherwise. Ranges are\n * considered equal if their start and end occur in the same container and\n * offset.\n *\n * @param {Range} a First range object to test.\n * @param {Range} b First range object to test.\n *\n * @return {boolean} Whether the two ranges are equal.\n */\nfunction isRangeEqual( a, b ) {\n\treturn (\n\t\ta.startContainer === b.startContainer &&\n\t\ta.startOffset === b.startOffset &&\n\t\ta.endContainer === b.endContainer &&\n\t\ta.endOffset === b.endOffset\n\t);\n}\n\nexport function applySelection( selection, current ) {\n\tconst { node: startContainer, offset: startOffset } = getNodeByPath( current, selection.startPath );\n\tconst { node: endContainer, offset: endOffset } = getNodeByPath( current, selection.endPath );\n\n\tconst windowSelection = window.getSelection();\n\tconst range = current.ownerDocument.createRange();\n\tconst collapsed = startContainer === endContainer && startOffset === endOffset;\n\n\tif (\n\t\tcollapsed &&\n\t\tstartOffset === 0 &&\n\t\tstartContainer.previousSibling &&\n\t\tstartContainer.previousSibling.nodeType === ELEMENT_NODE &&\n\t\tstartContainer.previousSibling.nodeName !== 'BR'\n\t) {\n\t\tstartContainer.insertData( 0, '\\uFEFF' );\n\t\trange.setStart( startContainer, 1 );\n\t\trange.setEnd( endContainer, 1 );\n\t} else if (\n\t\tcollapsed &&\n\t\tstartOffset === 0 &&\n\t\tstartContainer === TEXT_NODE &&\n\t\tstartContainer.nodeValue.length === 0\n\t) {\n\t\tstartContainer.insertData( 0, '\\uFEFF' );\n\t\trange.setStart( startContainer, 1 );\n\t\trange.setEnd( endContainer, 1 );\n\t} else {\n\t\trange.setStart( startContainer, startOffset );\n\t\trange.setEnd( endContainer, endOffset );\n\t}\n\n\tif ( windowSelection.rangeCount > 0 ) {\n\t\t// If the to be added range and the live range are the same, there's no\n\t\t// need to remove the live range and add the equivalent range.\n\t\tif ( isRangeEqual( range, windowSelection.getRangeAt( 0 ) ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\twindowSelection.removeAllRanges();\n\t}\n\n\twindowSelection.addRange( range );\n}\n"]}