{"version":3,"sources":["/Users/riad/Workspace/a8c/gutenberg/packages/blocks/src/api/parser.js"],"names":["parse","hpqParse","flow","castArray","mapValues","omit","stubFalse","autop","applyFilters","defaultParse","getBlockType","getFreeformContentHandlerName","getUnregisteredTypeHandlerName","createBlock","isValidBlockContent","getCommentDelimitedContent","attr","html","text","query","node","children","prop","normalizeBlockType","STRING_SOURCES","Set","toBooleanAttributeMatcher","matcher","value","undefined","isOfType","type","constructor","Object","Array","isArray","isOfTypes","types","some","isAmbiguousStringSource","attributeSchema","source","isStringSource","has","isSingleType","asType","String","Boolean","from","Number","matcherFromSource","sourceConfig","selector","attribute","multiline","subMatchers","toLowerCase","console","error","parseWithAttributeSchema","innerHTML","getBlockAttribute","attributeKey","commentAttributes","default","getBlockAttributes","blockTypeOrName","attributes","blockType","blockAttributes","getMigratedBlock","block","name","deprecatedDefinitions","deprecated","length","originalContent","innerBlocks","i","isEligible","isValid","deprecatedBlockType","assign","migratedAttributes","migratedInnerBlocks","migrate","createBlockWithFallback","blockNode","originalName","blockName","attrs","freeformContentFallbackBlock","unregisteredFallbackBlock","trim","originalUndelimitedContent","map","isFallbackBlock","createParse","parseImplementation","content","reduce","memo","push","parseWithGrammar"],"mappings":";;;AAAA;;;AAGA,SAASA,KAAK,IAAIC,QAAlB,QAAkC,KAAlC;AACA,SAASC,IAAT,EAAeC,SAAf,EAA0BC,SAA1B,EAAqCC,IAArC,EAA2CC,SAA3C,QAA4D,QAA5D;AAEA;;;;AAGA,SAASC,KAAT,QAAsB,kBAAtB;AACA,SAASC,YAAT,QAA6B,kBAA7B;AACA,SAASR,KAAK,IAAIS,YAAlB,QAAsC,+CAAtC;AAEA;;;;AAGA,SACCC,YADD,EAECC,6BAFD,EAGCC,8BAHD,QAIO,gBAJP;AAKA,SAASC,WAAT,QAA4B,WAA5B;AACA,SAASC,mBAAT,QAAoC,cAApC;AACA,SAASC,0BAAT,QAA2C,cAA3C;AACA,SAASC,IAAT,EAAeC,IAAf,EAAqBC,IAArB,EAA2BC,KAA3B,EAAkCC,IAAlC,EAAwCC,QAAxC,EAAkDC,IAAlD,QAA8D,YAA9D;AACA,SAASC,kBAAT,QAAmC,SAAnC;AAEA;;;;;;AAKA,IAAMC,cAAc,GAAG,IAAIC,GAAJ,CAAS,CAC/B,WAD+B,EAE/B,MAF+B,EAG/B,MAH+B,EAI/B,KAJ+B,CAAT,CAAvB;AAOA;;;;;;;;;;;;AAWA,OAAO,IAAMC,yBAAyB,GAAG,SAA5BA,yBAA4B,CAAEC,OAAF;AAAA,SAAezB,IAAI,CAAE,CAC7DyB,OAD6D,EAE7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAEC,KAAF;AAAA,WAAaA,KAAK,KAAKC,SAAvB;AAAA,GAf6D,CAAF,CAAnB;AAAA,CAAlC;AAkBP;;;;;;;;;;;AAUA,OAAO,SAASC,QAAT,CAAmBF,KAAnB,EAA0BG,IAA1B,EAAiC;AACvC,UAASA,IAAT;AACC,SAAK,QAAL;AACC,aAAO,OAAOH,KAAP,KAAiB,QAAxB;;AAED,SAAK,SAAL;AACC,aAAO,OAAOA,KAAP,KAAiB,SAAxB;;AAED,SAAK,QAAL;AACC,aAAO,CAAC,CAAEA,KAAH,IAAYA,KAAK,CAACI,WAAN,KAAsBC,MAAzC;;AAED,SAAK,MAAL;AACC,aAAOL,KAAK,KAAK,IAAjB;;AAED,SAAK,OAAL;AACC,aAAOM,KAAK,CAACC,OAAN,CAAeP,KAAf,CAAP;;AAED,SAAK,SAAL;AACA,SAAK,QAAL;AACC,aAAO,OAAOA,KAAP,KAAiB,QAAxB;AAlBF;;AAqBA,SAAO,IAAP;AACA;AAED;;;;;;;;;;;;AAWA,OAAO,SAASQ,SAAT,CAAoBR,KAApB,EAA2BS,KAA3B,EAAmC;AACzC,SAAOA,KAAK,CAACC,IAAN,CAAY,UAAEP,IAAF;AAAA,WAAYD,QAAQ,CAAEF,KAAF,EAASG,IAAT,CAApB;AAAA,GAAZ,CAAP;AACA;AAED;;;;;;;;;;;;;;;AAcA,OAAO,SAASQ,uBAAT,CAAkCC,eAAlC,EAAoD;AAAA,MAClDC,MADkD,GACjCD,eADiC,CAClDC,MADkD;AAAA,MAC1CV,IAD0C,GACjCS,eADiC,CAC1CT,IAD0C;AAG1D,MAAMW,cAAc,GAAGlB,cAAc,CAACmB,GAAf,CAAoBF,MAApB,CAAvB;AACA,MAAMG,YAAY,GAAG,OAAOb,IAAP,KAAgB,QAArC;AAEA,SAAOW,cAAc,IAAIE,YAAzB;AACA;AAED;;;;;;;;;;;AAUA,OAAO,SAASC,MAAT,CAAiBjB,KAAjB,EAAwBG,IAAxB,EAA+B;AACrC,UAASA,IAAT;AACC,SAAK,QAAL;AACC,aAAOe,MAAM,CAAElB,KAAF,CAAb;;AAED,SAAK,SAAL;AACC,aAAOmB,OAAO,CAAEnB,KAAF,CAAd;;AAED,SAAK,QAAL;AACC,aAAOK,MAAM,CAAEL,KAAF,CAAb;;AAED,SAAK,MAAL;AACC,aAAO,IAAP;;AAED,SAAK,OAAL;AACC,UAAKM,KAAK,CAACC,OAAN,CAAeP,KAAf,CAAL,EAA8B;AAC7B,eAAOA,KAAP;AACA;;AAED,aAAOM,KAAK,CAACc,IAAN,CAAYpB,KAAZ,CAAP;;AAED,SAAK,SAAL;AACA,SAAK,QAAL;AACC,aAAOqB,MAAM,CAAErB,KAAF,CAAb;AAtBF;;AAyBA,SAAOA,KAAP;AACA;AAED;;;;;;;;AAOA,OAAO,SAASsB,iBAAT,CAA4BC,YAA5B,EAA2C;AACjD,UAASA,YAAY,CAACV,MAAtB;AACC,SAAK,WAAL;AACC,UAAId,OAAO,GAAGX,IAAI,CAAEmC,YAAY,CAACC,QAAf,EAAyBD,YAAY,CAACE,SAAtC,CAAlB;;AACA,UAAKF,YAAY,CAACpB,IAAb,KAAsB,SAA3B,EAAuC;AACtCJ,QAAAA,OAAO,GAAGD,yBAAyB,CAAEC,OAAF,CAAnC;AACA;;AAED,aAAOA,OAAP;;AACD,SAAK,MAAL;AACC,aAAOV,IAAI,CAAEkC,YAAY,CAACC,QAAf,EAAyBD,YAAY,CAACG,SAAtC,CAAX;;AACD,SAAK,MAAL;AACC,aAAOpC,IAAI,CAAEiC,YAAY,CAACC,QAAf,CAAX;;AACD,SAAK,UAAL;AACC,aAAO/B,QAAQ,CAAE8B,YAAY,CAACC,QAAf,CAAf;;AACD,SAAK,MAAL;AACC,aAAOhC,IAAI,CAAE+B,YAAY,CAACC,QAAf,CAAX;;AACD,SAAK,OAAL;AACC,UAAMG,WAAW,GAAGnD,SAAS,CAAE+C,YAAY,CAAChC,KAAf,EAAsB+B,iBAAtB,CAA7B;AACA,aAAO/B,KAAK,CAAEgC,YAAY,CAACC,QAAf,EAAyBG,WAAzB,CAAZ;;AACD,SAAK,KAAL;AACC,aAAOrD,IAAI,CAAE,CACZoB,IAAI,CAAE6B,YAAY,CAACC,QAAf,EAAyB,UAAzB,CADQ,EAEZ,UAAExB,KAAF;AAAA,eAAaA,KAAK,CAAC4B,WAAN,EAAb;AAAA,OAFY,CAAF,CAAX;;AAID;AACC;AACAC,MAAAA,OAAO,CAACC,KAAR,iCAAwCP,YAAY,CAACV,MAArD;AA1BF;AA4BA;AAED;;;;;;;;;;AASA,OAAO,SAASkB,wBAAT,CAAmCC,SAAnC,EAA8CpB,eAA9C,EAAgE;AACtE,SAAOvC,QAAQ,CAAE2D,SAAF,EAAaV,iBAAiB,CAAEV,eAAF,CAA9B,CAAf;AACA;AAED;;;;;;;;;;;;;AAYA,OAAO,SAASqB,iBAAT,CAA4BC,YAA5B,EAA0CtB,eAA1C,EAA2DoB,SAA3D,EAAsEG,iBAAtE,EAA0F;AAAA,MACxFhC,IADwF,GAC/ES,eAD+E,CACxFT,IADwF;AAEhG,MAAIH,KAAJ;;AAEA,UAASY,eAAe,CAACC,MAAzB;AACC;AACA,SAAKZ,SAAL;AACCD,MAAAA,KAAK,GAAGmC,iBAAiB,GAAGA,iBAAiB,CAAED,YAAF,CAApB,GAAuCjC,SAAhE;AACA;;AACD,SAAK,WAAL;AACA,SAAK,UAAL;AACA,SAAK,MAAL;AACA,SAAK,MAAL;AACA,SAAK,UAAL;AACA,SAAK,MAAL;AACA,SAAK,OAAL;AACA,SAAK,KAAL;AACCD,MAAAA,KAAK,GAAG+B,wBAAwB,CAAEC,SAAF,EAAapB,eAAb,CAAhC;AACA;AAdF;;AAiBA,MAAKT,IAAI,KAAKF,SAAT,IAAsB,CAAEO,SAAS,CAAER,KAAF,EAASzB,SAAS,CAAE4B,IAAF,CAAlB,CAAtC,EAAqE;AACpE;AACA;AACAH,IAAAA,KAAK,GAAGC,SAAR;AACA;;AAED,MAAKD,KAAK,KAAKC,SAAf,EAA2B;AAC1B,WAAOW,eAAe,CAACwB,OAAvB;AACA;;AAED,SAAOpC,KAAP;AACA;AAED;;;;;;;;;;AASA,OAAO,SAASqC,kBAAT,CAA6BC,eAA7B,EAA8CN,SAA9C,EAA2E;AAAA,MAAlBO,UAAkB,uEAAL,EAAK;AACjF,MAAMC,SAAS,GAAG7C,kBAAkB,CAAE2C,eAAF,CAApC;AACA,MAAMG,eAAe,GAAGjE,SAAS,CAAEgE,SAAS,CAACD,UAAZ,EAAwB,UAAE3B,eAAF,EAAmBsB,YAAnB,EAAqC;AAC7F,WAAOD,iBAAiB,CAAEC,YAAF,EAAgBtB,eAAhB,EAAiCoB,SAAjC,EAA4CO,UAA5C,CAAxB;AACA,GAFgC,CAAjC;AAIA,SAAO3D,YAAY,CAClB,2BADkB,EAElB6D,eAFkB,EAGlBD,SAHkB,EAIlBR,SAJkB,EAKlBO,UALkB,CAAnB;AAOA;AAED;;;;;;;;;;AASA,OAAO,SAASG,gBAAT,CAA2BC,KAA3B,EAAmC;AACzC,MAAMH,SAAS,GAAG1D,YAAY,CAAE6D,KAAK,CAACC,IAAR,CAA9B;AADyC,MAGrBC,qBAHqB,GAGKL,SAHL,CAGjCM,UAHiC;;AAIzC,MAAK,CAAED,qBAAF,IAA2B,CAAEA,qBAAqB,CAACE,MAAxD,EAAiE;AAChE,WAAOJ,KAAP;AACA;;AANwC,eAQYA,KARZ;AAAA,MAQjCK,eARiC,UAQjCA,eARiC;AAAA,MAQhBT,UARgB,UAQhBA,UARgB;AAAA,MAQJU,WARI,UAQJA,WARI;;AAUzC,OAAM,IAAIC,CAAC,GAAG,CAAd,EAAiBA,CAAC,GAAGL,qBAAqB,CAACE,MAA3C,EAAmDG,CAAC,EAApD,EAAyD;AACxD;AACA;AACA;AAHwD,gCAIrBL,qBAAqB,CAAEK,CAAF,CAJA,CAIhDC,UAJgD;AAAA,QAIhDA,UAJgD,sCAInCzE,SAJmC;;AAKxD,QAAKiE,KAAK,CAACS,OAAN,IAAiB,CAAED,UAAU,CAAEZ,UAAF,EAAcU,WAAd,CAAlC,EAAgE;AAC/D;AACA,KAPuD,CASxD;AACA;AACA;;;AACA,QAAMI,mBAAmB,GAAGhD,MAAM,CAACiD,MAAP,CAC3B7E,IAAI,CAAE+D,SAAF,EAAa,CAAE,YAAF,EAAgB,MAAhB,EAAwB,UAAxB,CAAb,CADuB,EAE3BK,qBAAqB,CAAEK,CAAF,CAFM,CAA5B;AAKA,QAAIK,kBAAkB,GAAGlB,kBAAkB,CAC1CgB,mBAD0C,EAE1CL,eAF0C,EAG1CT,UAH0C,CAA3C,CAjBwD,CAuBxD;;AACA,QAAMa,OAAO,GAAGlE,mBAAmB,CAClCmE,mBADkC,EAElCE,kBAFkC,EAGlCP,eAHkC,CAAnC;;AAMA,QAAK,CAAEI,OAAP,EAAiB;AAChB;AACA;;AAEDT,IAAAA,KAAK,qBACDA,KADC;AAEJS,MAAAA,OAAO,EAAE;AAFL,MAAL;AAKA,QAAII,mBAAmB,GAAGP,WAA1B,CAvCwD,CAyCxD;AACA;;AA1CwD,QA2ChDQ,OA3CgD,GA2CpCJ,mBA3CoC,CA2ChDI,OA3CgD;;AA4CxD,QAAKA,OAAL,EAAe;AAAA,uBAIVlF,SAAS,CAAEkF,OAAO,CAAEF,kBAAF,EAAsBN,WAAtB,CAAT,CAJC;;AAAA;;AAAA;AAEbM,MAAAA,kBAFa,6BAEQhB,UAFR;AAAA;AAGbiB,MAAAA,mBAHa,8BAGSP,WAHT;AAKd;;AAEDN,IAAAA,KAAK,CAACJ,UAAN,GAAmBgB,kBAAnB;AACAZ,IAAAA,KAAK,CAACM,WAAN,GAAoBO,mBAApB;AACA;;AAED,SAAOb,KAAP;AACA;AAED;;;;;;;;AAOA,OAAO,SAASe,uBAAT,CAAkCC,SAAlC,EAA8C;AAAA,MACjCC,YADiC,GAChBD,SADgB,CAC5CE,SAD4C;AAAA,MAG5CtB,UAH4C,GAMhDoB,SANgD,CAGnDG,KAHmD;AAAA,8BAMhDH,SANgD,CAInDV,WAJmD;AAAA,MAInDA,WAJmD,sCAIrC,EAJqC;AAAA,MAKnDjB,SALmD,GAMhD2B,SANgD,CAKnD3B,SALmD;AAOpD,MAAM+B,4BAA4B,GAAGhF,6BAA6B,EAAlE;AACA,MAAMiF,yBAAyB,GAAGhF,8BAA8B,MAAM+E,4BAAtE;AAEAxB,EAAAA,UAAU,GAAGA,UAAU,IAAI,EAA3B,CAVoD,CAYpD;;AACAP,EAAAA,SAAS,GAAGA,SAAS,CAACiC,IAAV,EAAZ,CAboD,CAepD;AACA;;AACA,MAAIrB,IAAI,GAAGgB,YAAY,IAAIG,4BAA3B,CAjBoD,CAmBpD;;AACA,MAAK,uBAAuBnB,IAA5B,EAAmC;AAClCA,IAAAA,IAAI,GAAG,YAAP;AACA,GAtBmD,CAwBpD;;;AACA,MAAK,gBAAgBA,IAAhB,IAAwB,sBAAsBA,IAAnD,EAA0D;AACzDA,IAAAA,IAAI,GAAG,gBAAP;AACA,GA3BmD,CA6BpD;AACA;AACA;;;AACA,MAAKA,IAAI,KAAKmB,4BAAd,EAA6C;AAC5C/B,IAAAA,SAAS,GAAGrD,KAAK,CAAEqD,SAAF,CAAL,CAAmBiC,IAAnB,EAAZ;AACA,GAlCmD,CAoCpD;;;AACA,MAAIzB,SAAS,GAAG1D,YAAY,CAAE8D,IAAF,CAA5B;;AAEA,MAAK,CAAEJ,SAAP,EAAmB;AAClB;AACA,QAAM0B,0BAA0B,GAAGlC,SAAnC,CAFkB,CAIlB;AACA;;AACA,QAAKY,IAAL,EAAY;AACXZ,MAAAA,SAAS,GAAG7C,0BAA0B,CAAEyD,IAAF,EAAQL,UAAR,EAAoBP,SAApB,CAAtC;AACA;;AAEDY,IAAAA,IAAI,GAAGoB,yBAAP;AACAzB,IAAAA,UAAU,GAAG;AAAEqB,MAAAA,YAAY,EAAZA,YAAF;AAAgBM,MAAAA,0BAA0B,EAA1BA;AAAhB,KAAb;AACA1B,IAAAA,SAAS,GAAG1D,YAAY,CAAE8D,IAAF,CAAxB;AACA,GApDmD,CAsDpD;;;AACAK,EAAAA,WAAW,GAAGA,WAAW,CAACkB,GAAZ,CAAiBT,uBAAjB,CAAd;AAEA,MAAMU,eAAe,GACpBxB,IAAI,KAAKmB,4BAAT,IACAnB,IAAI,KAAKoB,yBAFV,CAzDoD,CA8DpD;;AACA,MAAK,CAAExB,SAAF,IAAiB,CAAER,SAAF,IAAeoC,eAArC,EAAyD;AACxD;AACA;;AAED,MAAIzB,KAAK,GAAG1D,WAAW,CACtB2D,IADsB,EAEtBP,kBAAkB,CAAEG,SAAF,EAAaR,SAAb,EAAwBO,UAAxB,CAFI,EAGtBU,WAHsB,CAAvB,CAnEoD,CAyEpD;AACA;AACA;AACA;;AACA,MAAK,CAAEmB,eAAP,EAAyB;AACxBzB,IAAAA,KAAK,CAACS,OAAN,GAAgBlE,mBAAmB,CAAEsD,SAAF,EAAaG,KAAK,CAACJ,UAAnB,EAA+BP,SAA/B,CAAnC;AACA,GA/EmD,CAiFpD;AACA;;;AACAW,EAAAA,KAAK,CAACK,eAAN,GAAwBhB,SAAxB;AAEAW,EAAAA,KAAK,GAAGD,gBAAgB,CAAEC,KAAF,CAAxB;AAEA,SAAOA,KAAP;AACA;AAED;;;;;;;;AAOA,IAAM0B,WAAW,GAAG,SAAdA,WAAc,CAAEC,mBAAF;AAAA,SACnB,UAAEC,OAAF;AAAA,WAAeD,mBAAmB,CAAEC,OAAF,CAAnB,CAA+BC,MAA/B,CAAuC,UAAEC,IAAF,EAAQd,SAAR,EAAuB;AAC5E,UAAMhB,KAAK,GAAGe,uBAAuB,CAAEC,SAAF,CAArC;;AACA,UAAKhB,KAAL,EAAa;AACZ8B,QAAAA,IAAI,CAACC,IAAL,CAAW/B,KAAX;AACA;;AACD,aAAO8B,IAAP;AACA,KANc,EAMZ,EANY,CAAf;AAAA,GADmB;AAAA,CAApB;AASA;;;;;;;;;AAOA,OAAO,IAAME,gBAAgB,GAAGN,WAAW,CAAExF,YAAF,CAApC;AAEP,eAAe8F,gBAAf","sourcesContent":["/**\n * External dependencies\n */\nimport { parse as hpqParse } from 'hpq';\nimport { flow, castArray, mapValues, omit, stubFalse } from 'lodash';\n\n/**\n * WordPress dependencies\n */\nimport { autop } from '@wordpress/autop';\nimport { applyFilters } from '@wordpress/hooks';\nimport { parse as defaultParse } from '@wordpress/block-serialization-default-parser';\n\n/**\n * Internal dependencies\n */\nimport {\n\tgetBlockType,\n\tgetFreeformContentHandlerName,\n\tgetUnregisteredTypeHandlerName,\n} from './registration';\nimport { createBlock } from './factory';\nimport { isValidBlockContent } from './validation';\nimport { getCommentDelimitedContent } from './serializer';\nimport { attr, html, text, query, node, children, prop } from './matchers';\nimport { normalizeBlockType } from './utils';\n\n/**\n * Sources which are guaranteed to return a string value.\n *\n * @type {Set}\n */\nconst STRING_SOURCES = new Set( [\n\t'attribute',\n\t'html',\n\t'text',\n\t'tag',\n] );\n\n/**\n * Higher-order hpq matcher which enhances an attribute matcher to return true\n * or false depending on whether the original matcher returns undefined. This\n * is useful for boolean attributes (e.g. disabled) whose attribute values may\n * be technically falsey (empty string), though their mere presence should be\n * enough to infer as true.\n *\n * @param {Function} matcher Original hpq matcher.\n *\n * @return {Function} Enhanced hpq matcher.\n */\nexport const toBooleanAttributeMatcher = ( matcher ) => flow( [\n\tmatcher,\n\t// Expected values from `attr( 'disabled' )`:\n\t//\n\t// <input>\n\t// - Value:       `undefined`\n\t// - Transformed: `false`\n\t//\n\t// <input disabled>\n\t// - Value:       `''`\n\t// - Transformed: `true`\n\t//\n\t// <input disabled=\"disabled\">\n\t// - Value:       `'disabled'`\n\t// - Transformed: `true`\n\t( value ) => value !== undefined,\n] );\n\n/**\n * Returns true if value is of the given JSON schema type, or false otherwise.\n *\n * @see http://json-schema.org/latest/json-schema-validation.html#rfc.section.6.25\n *\n * @param {*}      value Value to test.\n * @param {string} type  Type to test.\n *\n * @return {boolean} Whether value is of type.\n */\nexport function isOfType( value, type ) {\n\tswitch ( type ) {\n\t\tcase 'string':\n\t\t\treturn typeof value === 'string';\n\n\t\tcase 'boolean':\n\t\t\treturn typeof value === 'boolean';\n\n\t\tcase 'object':\n\t\t\treturn !! value && value.constructor === Object;\n\n\t\tcase 'null':\n\t\t\treturn value === null;\n\n\t\tcase 'array':\n\t\t\treturn Array.isArray( value );\n\n\t\tcase 'integer':\n\t\tcase 'number':\n\t\t\treturn typeof value === 'number';\n\t}\n\n\treturn true;\n}\n\n/**\n * Returns true if value is of an array of given JSON schema types, or false\n * otherwise.\n *\n * @see http://json-schema.org/latest/json-schema-validation.html#rfc.section.6.25\n *\n * @param {*}        value Value to test.\n * @param {string[]} types Types to test.\n *\n * @return {boolean} Whether value is of types.\n */\nexport function isOfTypes( value, types ) {\n\treturn types.some( ( type ) => isOfType( value, type ) );\n}\n\n/**\n * Returns true if the given attribute schema describes a value which may be\n * an ambiguous string.\n *\n * Some sources are ambiguously serialized as strings, for which value casting\n * is enabled. This is only possible when a singular type is assigned to the\n * attribute schema, since the string ambiguity makes it impossible to know the\n * correct type of multiple to which to cast.\n *\n * @param {Object} attributeSchema Attribute's schema.\n *\n * @return {boolean} Whether attribute schema defines an ambiguous string\n *                   source.\n */\nexport function isAmbiguousStringSource( attributeSchema ) {\n\tconst { source, type } = attributeSchema;\n\n\tconst isStringSource = STRING_SOURCES.has( source );\n\tconst isSingleType = typeof type === 'string';\n\n\treturn isStringSource && isSingleType;\n}\n\n/**\n * Returns value coerced to the specified JSON schema type string.\n *\n * @see http://json-schema.org/latest/json-schema-validation.html#rfc.section.6.25\n *\n * @param {*}      value Original value.\n * @param {string} type  Type to coerce.\n *\n * @return {*} Coerced value.\n */\nexport function asType( value, type ) {\n\tswitch ( type ) {\n\t\tcase 'string':\n\t\t\treturn String( value );\n\n\t\tcase 'boolean':\n\t\t\treturn Boolean( value );\n\n\t\tcase 'object':\n\t\t\treturn Object( value );\n\n\t\tcase 'null':\n\t\t\treturn null;\n\n\t\tcase 'array':\n\t\t\tif ( Array.isArray( value ) ) {\n\t\t\t\treturn value;\n\t\t\t}\n\n\t\t\treturn Array.from( value );\n\n\t\tcase 'integer':\n\t\tcase 'number':\n\t\t\treturn Number( value );\n\t}\n\n\treturn value;\n}\n\n/**\n * Returns an hpq matcher given a source object.\n *\n * @param {Object} sourceConfig Attribute Source object.\n *\n * @return {Function} A hpq Matcher.\n */\nexport function matcherFromSource( sourceConfig ) {\n\tswitch ( sourceConfig.source ) {\n\t\tcase 'attribute':\n\t\t\tlet matcher = attr( sourceConfig.selector, sourceConfig.attribute );\n\t\t\tif ( sourceConfig.type === 'boolean' ) {\n\t\t\t\tmatcher = toBooleanAttributeMatcher( matcher );\n\t\t\t}\n\n\t\t\treturn matcher;\n\t\tcase 'html':\n\t\t\treturn html( sourceConfig.selector, sourceConfig.multiline );\n\t\tcase 'text':\n\t\t\treturn text( sourceConfig.selector );\n\t\tcase 'children':\n\t\t\treturn children( sourceConfig.selector );\n\t\tcase 'node':\n\t\t\treturn node( sourceConfig.selector );\n\t\tcase 'query':\n\t\t\tconst subMatchers = mapValues( sourceConfig.query, matcherFromSource );\n\t\t\treturn query( sourceConfig.selector, subMatchers );\n\t\tcase 'tag':\n\t\t\treturn flow( [\n\t\t\t\tprop( sourceConfig.selector, 'nodeName' ),\n\t\t\t\t( value ) => value.toLowerCase(),\n\t\t\t] );\n\t\tdefault:\n\t\t\t// eslint-disable-next-line no-console\n\t\t\tconsole.error( `Unknown source type \"${ sourceConfig.source }\"` );\n\t}\n}\n\n/**\n * Given a block's raw content and an attribute's schema returns the attribute's\n * value depending on its source.\n *\n * @param {string} innerHTML         Block's raw content.\n * @param {Object} attributeSchema   Attribute's schema.\n *\n * @return {*} Attribute value.\n */\nexport function parseWithAttributeSchema( innerHTML, attributeSchema ) {\n\treturn hpqParse( innerHTML, matcherFromSource( attributeSchema ) );\n}\n\n/**\n * Given an attribute key, an attribute's schema, a block's raw content and the\n * commentAttributes returns the attribute value depending on its source\n * definition of the given attribute key.\n *\n * @param {string} attributeKey      Attribute key.\n * @param {Object} attributeSchema   Attribute's schema.\n * @param {string} innerHTML         Block's raw content.\n * @param {Object} commentAttributes Block's comment attributes.\n *\n * @return {*} Attribute value.\n */\nexport function getBlockAttribute( attributeKey, attributeSchema, innerHTML, commentAttributes ) {\n\tconst { type } = attributeSchema;\n\tlet value;\n\n\tswitch ( attributeSchema.source ) {\n\t\t// undefined source means that it's an attribute serialized to the block's \"comment\"\n\t\tcase undefined:\n\t\t\tvalue = commentAttributes ? commentAttributes[ attributeKey ] : undefined;\n\t\t\tbreak;\n\t\tcase 'attribute':\n\t\tcase 'property':\n\t\tcase 'html':\n\t\tcase 'text':\n\t\tcase 'children':\n\t\tcase 'node':\n\t\tcase 'query':\n\t\tcase 'tag':\n\t\t\tvalue = parseWithAttributeSchema( innerHTML, attributeSchema );\n\t\t\tbreak;\n\t}\n\n\tif ( type !== undefined && ! isOfTypes( value, castArray( type ) ) ) {\n\t\t// Reject the value if it is not valid of type. Reverting to the\n\t\t// undefined value ensures the default is restored, if applicable.\n\t\tvalue = undefined;\n\t}\n\n\tif ( value === undefined ) {\n\t\treturn attributeSchema.default;\n\t}\n\n\treturn value;\n}\n\n/**\n * Returns the block attributes of a registered block node given its type.\n *\n * @param {string|Object} blockTypeOrName Block type or name.\n * @param {string}        innerHTML       Raw block content.\n * @param {?Object}       attributes      Known block attributes (from delimiters).\n *\n * @return {Object} All block attributes.\n */\nexport function getBlockAttributes( blockTypeOrName, innerHTML, attributes = {} ) {\n\tconst blockType = normalizeBlockType( blockTypeOrName );\n\tconst blockAttributes = mapValues( blockType.attributes, ( attributeSchema, attributeKey ) => {\n\t\treturn getBlockAttribute( attributeKey, attributeSchema, innerHTML, attributes );\n\t} );\n\n\treturn applyFilters(\n\t\t'blocks.getBlockAttributes',\n\t\tblockAttributes,\n\t\tblockType,\n\t\tinnerHTML,\n\t\tattributes\n\t);\n}\n\n/**\n * Given a block object, returns a new copy of the block with any applicable\n * deprecated migrations applied, or the original block if it was both valid\n * and no eligible migrations exist.\n *\n * @param {WPBlock} block Original block object.\n *\n * @return {WPBlock} Migrated block object.\n */\nexport function getMigratedBlock( block ) {\n\tconst blockType = getBlockType( block.name );\n\n\tconst { deprecated: deprecatedDefinitions } = blockType;\n\tif ( ! deprecatedDefinitions || ! deprecatedDefinitions.length ) {\n\t\treturn block;\n\t}\n\n\tconst { originalContent, attributes, innerBlocks } = block;\n\n\tfor ( let i = 0; i < deprecatedDefinitions.length; i++ ) {\n\t\t// A block can opt into a migration even if the block is valid by\n\t\t// defining isEligible on its deprecation. If the block is both valid\n\t\t// and does not opt to migrate, skip.\n\t\tconst { isEligible = stubFalse } = deprecatedDefinitions[ i ];\n\t\tif ( block.isValid && ! isEligible( attributes, innerBlocks ) ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Block type properties which could impact either serialization or\n\t\t// parsing are not considered in the deprecated block type by default,\n\t\t// and must be explicitly provided.\n\t\tconst deprecatedBlockType = Object.assign(\n\t\t\tomit( blockType, [ 'attributes', 'save', 'supports' ] ),\n\t\t\tdeprecatedDefinitions[ i ]\n\t\t);\n\n\t\tlet migratedAttributes = getBlockAttributes(\n\t\t\tdeprecatedBlockType,\n\t\t\toriginalContent,\n\t\t\tattributes\n\t\t);\n\n\t\t// Ignore the deprecation if it produces a block which is not valid.\n\t\tconst isValid = isValidBlockContent(\n\t\t\tdeprecatedBlockType,\n\t\t\tmigratedAttributes,\n\t\t\toriginalContent\n\t\t);\n\n\t\tif ( ! isValid ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tblock = {\n\t\t\t...block,\n\t\t\tisValid: true,\n\t\t};\n\n\t\tlet migratedInnerBlocks = innerBlocks;\n\n\t\t// A block may provide custom behavior to assign new attributes and/or\n\t\t// inner blocks.\n\t\tconst { migrate } = deprecatedBlockType;\n\t\tif ( migrate ) {\n\t\t\t( [\n\t\t\t\tmigratedAttributes = attributes,\n\t\t\t\tmigratedInnerBlocks = innerBlocks,\n\t\t\t] = castArray( migrate( migratedAttributes, innerBlocks ) ) );\n\t\t}\n\n\t\tblock.attributes = migratedAttributes;\n\t\tblock.innerBlocks = migratedInnerBlocks;\n\t}\n\n\treturn block;\n}\n\n/**\n * Creates a block with fallback to the unknown type handler.\n *\n * @param {Object} blockNode Parsed block node.\n *\n * @return {?Object} An initialized block object (if possible).\n */\nexport function createBlockWithFallback( blockNode ) {\n\tconst { blockName: originalName } = blockNode;\n\tlet {\n\t\tattrs: attributes,\n\t\tinnerBlocks = [],\n\t\tinnerHTML,\n\t} = blockNode;\n\tconst freeformContentFallbackBlock = getFreeformContentHandlerName();\n\tconst unregisteredFallbackBlock = getUnregisteredTypeHandlerName() || freeformContentFallbackBlock;\n\n\tattributes = attributes || {};\n\n\t// Trim content to avoid creation of intermediary freeform segments.\n\tinnerHTML = innerHTML.trim();\n\n\t// Use type from block content if available. Otherwise, default to the\n\t// freeform content fallback.\n\tlet name = originalName || freeformContentFallbackBlock;\n\n\t// Convert 'core/cover-image' block in existing content to 'core/cover'.\n\tif ( 'core/cover-image' === name ) {\n\t\tname = 'core/cover';\n\t}\n\n\t// Convert 'core/text' blocks in existing content to 'core/paragraph'.\n\tif ( 'core/text' === name || 'core/cover-text' === name ) {\n\t\tname = 'core/paragraph';\n\t}\n\n\t// Fallback content may be upgraded from classic editor expecting implicit\n\t// automatic paragraphs, so preserve them. Assumes wpautop is idempotent,\n\t// meaning there are no negative consequences to repeated autop calls.\n\tif ( name === freeformContentFallbackBlock ) {\n\t\tinnerHTML = autop( innerHTML ).trim();\n\t}\n\n\t// Try finding the type for known block name, else fall back again.\n\tlet blockType = getBlockType( name );\n\n\tif ( ! blockType ) {\n\t\t// Preserve undelimited content for use by the unregistered type handler.\n\t\tconst originalUndelimitedContent = innerHTML;\n\n\t\t// If detected as a block which is not registered, preserve comment\n\t\t// delimiters in content of unregistered type handler.\n\t\tif ( name ) {\n\t\t\tinnerHTML = getCommentDelimitedContent( name, attributes, innerHTML );\n\t\t}\n\n\t\tname = unregisteredFallbackBlock;\n\t\tattributes = { originalName, originalUndelimitedContent };\n\t\tblockType = getBlockType( name );\n\t}\n\n\t// Coerce inner blocks from parsed form to canonical form.\n\tinnerBlocks = innerBlocks.map( createBlockWithFallback );\n\n\tconst isFallbackBlock = (\n\t\tname === freeformContentFallbackBlock ||\n\t\tname === unregisteredFallbackBlock\n\t);\n\n\t// Include in set only if type was determined.\n\tif ( ! blockType || ( ! innerHTML && isFallbackBlock ) ) {\n\t\treturn;\n\t}\n\n\tlet block = createBlock(\n\t\tname,\n\t\tgetBlockAttributes( blockType, innerHTML, attributes ),\n\t\tinnerBlocks\n\t);\n\n\t// Block validation assumes an idempotent operation from source block to serialized block\n\t// provided there are no changes in attributes. The validation procedure thus compares the\n\t// provided source value with the serialized output before there are any modifications to\n\t// the block. When both match, the block is marked as valid.\n\tif ( ! isFallbackBlock ) {\n\t\tblock.isValid = isValidBlockContent( blockType, block.attributes, innerHTML );\n\t}\n\n\t// Preserve original content for future use in case the block is parsed as\n\t// invalid, or future serialization attempt results in an error.\n\tblock.originalContent = innerHTML;\n\n\tblock = getMigratedBlock( block );\n\n\treturn block;\n}\n\n/**\n * Creates a parse implementation for the post content which returns a list of blocks.\n *\n * @param {Function} parseImplementation Parse implementation.\n *\n * @return {Function} An implementation which parses the post content.\n */\nconst createParse = ( parseImplementation ) =>\n\t( content ) => parseImplementation( content ).reduce( ( memo, blockNode ) => {\n\t\tconst block = createBlockWithFallback( blockNode );\n\t\tif ( block ) {\n\t\t\tmemo.push( block );\n\t\t}\n\t\treturn memo;\n\t}, [] );\n\n/**\n * Parses the post content with a PegJS grammar and returns a list of blocks.\n *\n * @param {string} content The post content.\n *\n * @return {Array} Block list.\n */\nexport const parseWithGrammar = createParse( defaultParse );\n\nexport default parseWithGrammar;\n"]}