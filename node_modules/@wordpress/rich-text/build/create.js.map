{"version":3,"sources":["/Users/riad/Workspace/a8c/gutenberg/packages/rich-text/src/create.js"],"names":["window","Node","TEXT_NODE","ELEMENT_NODE","createEmptyValue","formats","text","simpleFindKey","object","value","key","toFormat","type","attributes","formatType","class","getFormatTypeForClassName","replace","className","trim","getFormatTypeForBareElement","name","registeredAttributes","unregisteredAttributes","create","element","html","range","multilineTag","multilineWrapperTags","removeNode","unwrapNode","filterString","removeAttribute","length","Array","document","createFromElement","createFromMultilineElement","accumulateSelection","accumulator","node","parentNode","startContainer","startOffset","endContainer","endOffset","currentLength","start","undefined","nodeType","childNodes","end","filterRange","filter","nodeValue","slice","currentWrapperTags","hasChildNodes","filterStringComplete","string","index","nodeName","toLowerCase","lastFormats","lastFormat","format","newFormat","getAttributes","indexOf","OBJECT_REPLACEMENT_CHARACTER","unshift","i","formatIndex","push","children","concat","LINE_SEPARATOR","hasAttributes"],"mappings":"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","sourcesContent":["/**\n * WordPress dependencies\n */\nimport { select } from '@wordpress/data';\n\n/**\n * Internal dependencies\n */\n\nimport { isEmpty } from './is-empty';\nimport { isFormatEqual } from './is-format-equal';\nimport { createElement } from './create-element';\nimport {\n\tLINE_SEPARATOR,\n\tOBJECT_REPLACEMENT_CHARACTER,\n} from './special-characters';\n\n/**\n * Browser dependencies\n */\n\nconst { TEXT_NODE, ELEMENT_NODE } = window.Node;\n\nfunction createEmptyValue() {\n\treturn { formats: [], text: '' };\n}\n\nfunction simpleFindKey( object, value ) {\n\tfor ( const key in object ) {\n\t\tif ( object[ key ] === value ) {\n\t\t\treturn key;\n\t\t}\n\t}\n}\n\nfunction toFormat( { type, attributes } ) {\n\tlet formatType;\n\n\tif ( attributes && attributes.class ) {\n\t\tformatType = select( 'core/rich-text' ).getFormatTypeForClassName( attributes.class );\n\n\t\tif ( formatType ) {\n\t\t\t// Preserve any additional classes.\n\t\t\tattributes.class = ` ${ attributes.class } `.replace( ` ${ formatType.className } `, ' ' ).trim();\n\n\t\t\tif ( ! attributes.class ) {\n\t\t\t\tdelete attributes.class;\n\t\t\t}\n\t\t}\n\t}\n\n\tif ( ! formatType ) {\n\t\tformatType = select( 'core/rich-text' ).getFormatTypeForBareElement( type );\n\t}\n\n\tif ( ! formatType ) {\n\t\treturn attributes ? { type, attributes } : { type };\n\t}\n\n\tif ( ! attributes ) {\n\t\treturn { type: formatType.name };\n\t}\n\n\tconst registeredAttributes = {};\n\tconst unregisteredAttributes = {};\n\n\tfor ( const name in attributes ) {\n\t\tconst key = simpleFindKey( formatType.attributes, name );\n\n\t\tif ( key ) {\n\t\t\tregisteredAttributes[ key ] = attributes[ name ];\n\t\t} else {\n\t\t\tunregisteredAttributes[ name ] = attributes[ name ];\n\t\t}\n\t}\n\n\treturn {\n\t\ttype: formatType.name,\n\t\tattributes: registeredAttributes,\n\t\tunregisteredAttributes,\n\t};\n}\n\n/**\n * Create a RichText value from an `Element` tree (DOM), an HTML string or a\n * plain text string, with optionally a `Range` object to set the selection. If\n * called without any input, an empty value will be created. If\n * `multilineTag` is provided, any content of direct children whose type matches\n * `multilineTag` will be separated by two newlines. The optional functions can\n * be used to filter out content.\n *\n * @param {?Object}   $1                      Optional named argements.\n * @param {?Element}  $1.element              Element to create value from.\n * @param {?string}   $1.text                 Text to create value from.\n * @param {?string}   $1.html                 HTML to create value from.\n * @param {?Range}    $1.range                Range to create value from.\n * @param {?string}   $1.multilineTag         Multiline tag if the structure is\n *                                            multiline.\n * @param {?Array}    $1.multilineWrapperTags Tags where lines can be found if\n *                                            nesting is possible.\n * @param {?Function} $1.removeNode           Function to declare whether the\n *                                            given node should be removed.\n * @param {?Function} $1.unwrapNode           Function to declare whether the\n *                                            given node should be unwrapped.\n * @param {?Function} $1.filterString         Function to filter the given\n *                                            string.\n * @param {?Function} $1.removeAttribute      Wether to remove an attribute\n *                                            based on the name.\n *\n * @return {Object} A rich text value.\n */\nexport function create( {\n\telement,\n\ttext,\n\thtml,\n\trange,\n\tmultilineTag,\n\tmultilineWrapperTags,\n\tremoveNode,\n\tunwrapNode,\n\tfilterString,\n\tremoveAttribute,\n} = {} ) {\n\tif ( typeof text === 'string' && text.length > 0 ) {\n\t\treturn {\n\t\t\tformats: Array( text.length ),\n\t\t\ttext: text,\n\t\t};\n\t}\n\n\tif ( typeof html === 'string' && html.length > 0 ) {\n\t\telement = createElement( document, html );\n\t}\n\n\tif ( typeof element !== 'object' ) {\n\t\treturn createEmptyValue();\n\t}\n\n\tif ( ! multilineTag ) {\n\t\treturn createFromElement( {\n\t\t\telement,\n\t\t\trange,\n\t\t\tremoveNode,\n\t\t\tunwrapNode,\n\t\t\tfilterString,\n\t\t\tremoveAttribute,\n\t\t} );\n\t}\n\n\treturn createFromMultilineElement( {\n\t\telement,\n\t\trange,\n\t\tmultilineTag,\n\t\tmultilineWrapperTags,\n\t\tremoveNode,\n\t\tunwrapNode,\n\t\tfilterString,\n\t\tremoveAttribute,\n\t} );\n}\n\n/**\n * Helper to accumulate the value's selection start and end from the current\n * node and range.\n *\n * @param {Object} accumulator Object to accumulate into.\n * @param {Node}   node        Node to create value with.\n * @param {Range}  range       Range to create value with.\n * @param {Object} value       Value that is being accumulated.\n */\nfunction accumulateSelection( accumulator, node, range, value ) {\n\tif ( ! range ) {\n\t\treturn;\n\t}\n\n\tconst { parentNode } = node;\n\tconst { startContainer, startOffset, endContainer, endOffset } = range;\n\tconst currentLength = accumulator.text.length;\n\n\t// Selection can be extracted from value.\n\tif ( value.start !== undefined ) {\n\t\taccumulator.start = currentLength + value.start;\n\t// Range indicates that the current node has selection.\n\t} else if ( node === startContainer && node.nodeType === TEXT_NODE ) {\n\t\taccumulator.start = currentLength + startOffset;\n\t// Range indicates that the current node is selected.\n\t} else if (\n\t\tparentNode === startContainer &&\n\t\tnode === startContainer.childNodes[ startOffset ]\n\t) {\n\t\taccumulator.start = currentLength;\n\t// Range indicates that the selection is after the current node.\n\t} else if (\n\t\tparentNode === startContainer &&\n\t\tnode === startContainer.childNodes[ startOffset - 1 ]\n\t) {\n\t\taccumulator.start = currentLength + value.text.length;\n\t// Fallback if no child inside handled the selection.\n\t} else if ( node === startContainer ) {\n\t\taccumulator.start = currentLength;\n\t}\n\n\t// Selection can be extracted from value.\n\tif ( value.end !== undefined ) {\n\t\taccumulator.end = currentLength + value.end;\n\t// Range indicates that the current node has selection.\n\t} else if ( node === endContainer && node.nodeType === TEXT_NODE ) {\n\t\taccumulator.end = currentLength + endOffset;\n\t// Range indicates that the current node is selected.\n\t} else if (\n\t\tparentNode === endContainer &&\n\t\tnode === endContainer.childNodes[ endOffset - 1 ]\n\t) {\n\t\taccumulator.end = currentLength + value.text.length;\n\t// Range indicates that the selection is before the current node.\n\t} else if (\n\t\tparentNode === endContainer &&\n\t\tnode === endContainer.childNodes[ endOffset ]\n\t) {\n\t\taccumulator.end = currentLength;\n\t// Fallback if no child inside handled the selection.\n\t} else if ( node === endContainer ) {\n\t\taccumulator.end = currentLength + endOffset;\n\t}\n}\n\n/**\n * Adjusts the start and end offsets from a range based on a text filter.\n *\n * @param {Node}     node   Node of which the text should be filtered.\n * @param {Range}    range  The range to filter.\n * @param {Function} filter Function to use to filter the text.\n *\n * @return {?Object} Object containing range properties.\n */\nfunction filterRange( node, range, filter ) {\n\tif ( ! range ) {\n\t\treturn;\n\t}\n\n\tconst { startContainer, endContainer } = range;\n\tlet { startOffset, endOffset } = range;\n\n\tif ( node === startContainer ) {\n\t\tstartOffset = filter( node.nodeValue.slice( 0, startOffset ) ).length;\n\t}\n\n\tif ( node === endContainer ) {\n\t\tendOffset = filter( node.nodeValue.slice( 0, endOffset ) ).length;\n\t}\n\n\treturn { startContainer, startOffset, endContainer, endOffset };\n}\n\n/**\n * Creates a Rich Text value from a DOM element and range.\n *\n * @param {Object}    $1                      Named argements.\n * @param {?Element}  $1.element              Element to create value from.\n * @param {?Range}    $1.range                Range to create value from.\n * @param {?string}   $1.multilineTag         Multiline tag if the structure is\n *                                            multiline.\n * @param {?Array}    $1.multilineWrapperTags Tags where lines can be found if\n *                                            nesting is possible.\n * @param {?Function} $1.removeNode           Function to declare whether the\n *                                            given node should be removed.\n * @param {?Function} $1.unwrapNode           Function to declare whether the\n *                                            given node should be unwrapped.\n * @param {?Function} $1.filterString         Function to filter the given\n *                                            string.\n * @param {?Function} $1.removeAttribute      Wether to remove an attribute\n *                                            based on the name.\n *\n * @return {Object} A rich text value.\n */\nfunction createFromElement( {\n\telement,\n\trange,\n\tmultilineTag,\n\tmultilineWrapperTags,\n\tcurrentWrapperTags = [],\n\tremoveNode,\n\tunwrapNode,\n\tfilterString,\n\tremoveAttribute,\n} ) {\n\tconst accumulator = createEmptyValue();\n\n\tif ( ! element ) {\n\t\treturn accumulator;\n\t}\n\n\tif ( ! element.hasChildNodes() ) {\n\t\taccumulateSelection( accumulator, element, range, createEmptyValue() );\n\t\treturn accumulator;\n\t}\n\n\tconst length = element.childNodes.length;\n\n\tconst filterStringComplete = ( string ) => {\n\t\t// Reduce any whitespace used for HTML formatting to one space\n\t\t// character, because it will also be displayed as such by the browser.\n\t\tstring = string.replace( /[\\n\\r\\t]+/g, ' ' );\n\n\t\tif ( filterString ) {\n\t\t\tstring = filterString( string );\n\t\t}\n\n\t\treturn string;\n\t};\n\n\t// Optimise for speed.\n\tfor ( let index = 0; index < length; index++ ) {\n\t\tconst node = element.childNodes[ index ];\n\t\tconst type = node.nodeName.toLowerCase();\n\n\t\tif ( node.nodeType === TEXT_NODE ) {\n\t\t\tconst text = filterStringComplete( node.nodeValue );\n\t\t\trange = filterRange( node, range, filterStringComplete );\n\t\t\taccumulateSelection( accumulator, node, range, { text } );\n\t\t\taccumulator.text += text;\n\t\t\t// Create a sparse array of the same length as `text`, in which\n\t\t\t// formats can be added.\n\t\t\taccumulator.formats.length += text.length;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ( node.nodeType !== ELEMENT_NODE ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (\n\t\t\t( removeNode && removeNode( node ) ) ||\n\t\t\t( unwrapNode && unwrapNode( node ) && ! node.hasChildNodes() )\n\t\t) {\n\t\t\taccumulateSelection( accumulator, node, range, createEmptyValue() );\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ( type === 'br' ) {\n\t\t\taccumulateSelection( accumulator, node, range, createEmptyValue() );\n\t\t\taccumulator.text += '\\n';\n\t\t\taccumulator.formats.length += 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst lastFormats = accumulator.formats[ accumulator.formats.length - 1 ];\n\t\tconst lastFormat = lastFormats && lastFormats[ lastFormats.length - 1 ];\n\t\tlet format;\n\t\tlet value;\n\n\t\tif ( ! unwrapNode || ! unwrapNode( node ) ) {\n\t\t\tconst newFormat = toFormat( {\n\t\t\t\ttype,\n\t\t\t\tattributes: getAttributes( {\n\t\t\t\t\telement: node,\n\t\t\t\t\tremoveAttribute,\n\t\t\t\t} ),\n\t\t\t} );\n\n\t\t\tif ( newFormat ) {\n\t\t\t\t// Reuse the last format if it's equal.\n\t\t\t\tif ( isFormatEqual( newFormat, lastFormat ) ) {\n\t\t\t\t\tformat = lastFormat;\n\t\t\t\t} else {\n\t\t\t\t\tformat = newFormat;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( multilineWrapperTags && multilineWrapperTags.indexOf( type ) !== -1 ) {\n\t\t\tvalue = createFromMultilineElement( {\n\t\t\t\telement: node,\n\t\t\t\trange,\n\t\t\t\tmultilineTag,\n\t\t\t\tmultilineWrapperTags,\n\t\t\t\tremoveNode,\n\t\t\t\tunwrapNode,\n\t\t\t\tfilterString,\n\t\t\t\tremoveAttribute,\n\t\t\t\tcurrentWrapperTags: [ ...currentWrapperTags, format ],\n\t\t\t} );\n\t\t\tformat = undefined;\n\t\t} else {\n\t\t\tvalue = createFromElement( {\n\t\t\t\telement: node,\n\t\t\t\trange,\n\t\t\t\tmultilineTag,\n\t\t\t\tmultilineWrapperTags,\n\t\t\t\tremoveNode,\n\t\t\t\tunwrapNode,\n\t\t\t\tfilterString,\n\t\t\t\tremoveAttribute,\n\t\t\t} );\n\t\t}\n\n\t\tconst text = value.text;\n\t\tconst start = accumulator.text.length;\n\n\t\taccumulateSelection( accumulator, node, range, value );\n\n\t\t// Don't apply the element as formatting if it has no content.\n\t\tif ( isEmpty( value ) && format && ! format.attributes ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst { formats } = accumulator;\n\n\t\tif ( format && format.attributes && text.length === 0 ) {\n\t\t\tformat.object = true;\n\t\t\taccumulator.text += OBJECT_REPLACEMENT_CHARACTER;\n\n\t\t\tif ( formats[ start ] ) {\n\t\t\t\tformats[ start ].unshift( format );\n\t\t\t} else {\n\t\t\t\tformats[ start ] = [ format ];\n\t\t\t}\n\t\t} else {\n\t\t\taccumulator.text += text;\n\t\t\taccumulator.formats.length += text.length;\n\n\t\t\tlet i = value.formats.length;\n\n\t\t\t// Optimise for speed.\n\t\t\twhile ( i-- ) {\n\t\t\t\tconst formatIndex = start + i;\n\n\t\t\t\tif ( format ) {\n\t\t\t\t\tif ( formats[ formatIndex ] ) {\n\t\t\t\t\t\tformats[ formatIndex ].push( format );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tformats[ formatIndex ] = [ format ];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ( value.formats[ i ] ) {\n\t\t\t\t\tif ( formats[ formatIndex ] ) {\n\t\t\t\t\t\tformats[ formatIndex ].push( ...value.formats[ i ] );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tformats[ formatIndex ] = value.formats[ i ];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn accumulator;\n}\n\n/**\n * Creates a rich text value from a DOM element and range that should be\n * multiline.\n *\n * @param {Object}    $1                      Named argements.\n * @param {?Element}  $1.element              Element to create value from.\n * @param {?Range}    $1.range                Range to create value from.\n * @param {?string}   $1.multilineTag         Multiline tag if the structure is\n *                                            multiline.\n * @param {?Array}    $1.multilineWrapperTags Tags where lines can be found if\n *                                            nesting is possible.\n * @param {?Function} $1.removeNode           Function to declare whether the\n *                                            given node should be removed.\n * @param {?Function} $1.unwrapNode           Function to declare whether the\n *                                            given node should be unwrapped.\n * @param {?Function} $1.filterString         Function to filter the given\n *                                            string.\n * @param {?Function} $1.removeAttribute      Wether to remove an attribute\n *                                            based on the name.\n * @param {boolean}   $1.currentWrapperTags   Whether to prepend a line\n *                                            separator.\n *\n * @return {Object} A rich text value.\n */\nfunction createFromMultilineElement( {\n\telement,\n\trange,\n\tmultilineTag,\n\tmultilineWrapperTags,\n\tremoveNode,\n\tunwrapNode,\n\tfilterString,\n\tremoveAttribute,\n\tcurrentWrapperTags = [],\n} ) {\n\tconst accumulator = createEmptyValue();\n\n\tif ( ! element || ! element.hasChildNodes() ) {\n\t\treturn accumulator;\n\t}\n\n\tconst length = element.children.length;\n\n\t// Optimise for speed.\n\tfor ( let index = 0; index < length; index++ ) {\n\t\tconst node = element.children[ index ];\n\n\t\tif ( node.nodeName.toLowerCase() !== multilineTag ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tlet value = createFromElement( {\n\t\t\telement: node,\n\t\t\trange,\n\t\t\tmultilineTag,\n\t\t\tmultilineWrapperTags,\n\t\t\tcurrentWrapperTags,\n\t\t\tremoveNode,\n\t\t\tunwrapNode,\n\t\t\tfilterString,\n\t\t\tremoveAttribute,\n\t\t} );\n\n\t\t// If a line consists of one single line break (invisible), consider the\n\t\t// line empty, wether this is the browser's doing or not.\n\t\tif ( value.text === '\\n' ) {\n\t\t\tconst start = value.start;\n\t\t\tconst end = value.end;\n\n\t\t\tvalue = createEmptyValue();\n\n\t\t\tif ( start !== undefined ) {\n\t\t\t\tvalue.start = 0;\n\t\t\t}\n\n\t\t\tif ( end !== undefined ) {\n\t\t\t\tvalue.end = 0;\n\t\t\t}\n\t\t}\n\n\t\t// Multiline value text should be separated by a double line break.\n\t\tif ( index !== 0 || currentWrapperTags.length > 0 ) {\n\t\t\tconst formats = currentWrapperTags.length > 0 ? [ currentWrapperTags ] : [ , ];\n\t\t\taccumulator.formats = accumulator.formats.concat( formats );\n\t\t\taccumulator.text += LINE_SEPARATOR;\n\t\t}\n\n\t\taccumulateSelection( accumulator, node, range, value );\n\n\t\taccumulator.formats = accumulator.formats.concat( value.formats );\n\t\taccumulator.text += value.text;\n\t}\n\n\treturn accumulator;\n}\n\n/**\n * Gets the attributes of an element in object shape.\n *\n * @param {Object}    $1                 Named argements.\n * @param {Element}   $1.element         Element to get attributes from.\n * @param {?Function} $1.removeAttribute Wether to remove an attribute based on\n *                                       the name.\n *\n * @return {?Object} Attribute object or `undefined` if the element has no\n *                   attributes.\n */\nfunction getAttributes( {\n\telement,\n\tremoveAttribute,\n} ) {\n\tif ( ! element.hasAttributes() ) {\n\t\treturn;\n\t}\n\n\tconst length = element.attributes.length;\n\tlet accumulator;\n\n\t// Optimise for speed.\n\tfor ( let i = 0; i < length; i++ ) {\n\t\tconst { name, value } = element.attributes[ i ];\n\n\t\tif ( removeAttribute && removeAttribute( name ) ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\taccumulator = accumulator || {};\n\t\taccumulator[ name ] = value;\n\t}\n\n\treturn accumulator;\n}\n"]}