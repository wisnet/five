{"version":3,"sources":["/Users/riad/Workspace/a8c/gutenberg/packages/rich-text/src/to-tree.js"],"names":["getFormatType","LINE_SEPARATOR","OBJECT_REPLACEMENT_CHARACTER","ZERO_WIDTH_NO_BREAK_SPACE","fromFormat","type","attributes","unregisteredAttributes","object","formatType","elementAttributes","name","key","className","class","tagName","toTree","value","multilineTag","multilineWrapperTags","createEmpty","append","getLastChild","getParent","isText","getText","remove","appendText","onStartIndex","onEndIndex","isEditableTree","formats","text","start","end","formatPlaceholder","formatsLength","length","tree","multilineFormat","lastSeparatorFormats","lastCharacterFormats","lastCharacter","setFormatPlaceholder","pointer","index","parent","format","undefined","i","character","charAt","characterFormats","reduce","accumulator","indexOf","push","node","forEach","formatIndex","newNode"],"mappings":"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","sourcesContent":["/**\n * Internal dependencies\n */\n\nimport { getFormatType } from './get-format-type';\nimport {\n\tLINE_SEPARATOR,\n\tOBJECT_REPLACEMENT_CHARACTER,\n\tZERO_WIDTH_NO_BREAK_SPACE,\n} from './special-characters';\n\nfunction fromFormat( { type, attributes, unregisteredAttributes, object } ) {\n\tconst formatType = getFormatType( type );\n\n\tif ( ! formatType ) {\n\t\treturn { type, attributes, object };\n\t}\n\n\tconst elementAttributes = { ...unregisteredAttributes };\n\n\tfor ( const name in attributes ) {\n\t\tconst key = formatType.attributes[ name ];\n\n\t\tif ( key ) {\n\t\t\telementAttributes[ key ] = attributes[ name ];\n\t\t} else {\n\t\t\telementAttributes[ name ] = attributes[ name ];\n\t\t}\n\t}\n\n\tif ( formatType.className ) {\n\t\tif ( elementAttributes.class ) {\n\t\t\telementAttributes.class = `${ formatType.className } ${ elementAttributes.class }`;\n\t\t} else {\n\t\t\telementAttributes.class = formatType.className;\n\t\t}\n\t}\n\n\treturn {\n\t\ttype: formatType.tagName,\n\t\tobject: formatType.object,\n\t\tattributes: elementAttributes,\n\t};\n}\n\nexport function toTree( {\n\tvalue,\n\tmultilineTag,\n\tmultilineWrapperTags = [],\n\tcreateEmpty,\n\tappend,\n\tgetLastChild,\n\tgetParent,\n\tisText,\n\tgetText,\n\tremove,\n\tappendText,\n\tonStartIndex,\n\tonEndIndex,\n\tisEditableTree,\n} ) {\n\tconst { formats, text, start, end, formatPlaceholder } = value;\n\tconst formatsLength = formats.length + 1;\n\tconst tree = createEmpty();\n\tconst multilineFormat = { type: multilineTag };\n\n\tlet lastSeparatorFormats;\n\tlet lastCharacterFormats;\n\tlet lastCharacter;\n\n\t// If we're building a multiline tree, start off with a multiline element.\n\tif ( multilineTag ) {\n\t\tappend( append( tree, { type: multilineTag } ), '' );\n\t\tlastCharacterFormats = lastSeparatorFormats = [ multilineFormat ];\n\t} else {\n\t\tappend( tree, '' );\n\t}\n\n\tfunction setFormatPlaceholder( pointer, index ) {\n\t\tif ( isEditableTree && formatPlaceholder && formatPlaceholder.index === index ) {\n\t\t\tconst parent = getParent( pointer );\n\n\t\t\tif ( formatPlaceholder.format === undefined ) {\n\t\t\t\tpointer = getParent( parent );\n\t\t\t} else {\n\t\t\t\tpointer = append( parent, fromFormat( formatPlaceholder.format ) );\n\t\t\t}\n\n\t\t\tpointer = append( pointer, ZERO_WIDTH_NO_BREAK_SPACE );\n\t\t}\n\n\t\treturn pointer;\n\t}\n\n\tfor ( let i = 0; i < formatsLength; i++ ) {\n\t\tconst character = text.charAt( i );\n\t\tlet characterFormats = formats[ i ];\n\n\t\t// Set multiline tags in queue for building the tree.\n\t\tif ( multilineTag ) {\n\t\t\tif ( character === LINE_SEPARATOR ) {\n\t\t\t\tcharacterFormats = lastSeparatorFormats = ( characterFormats || [] ).reduce( ( accumulator, format ) => {\n\t\t\t\t\tif ( character === LINE_SEPARATOR && multilineWrapperTags.indexOf( format.type ) !== -1 ) {\n\t\t\t\t\t\taccumulator.push( format );\n\t\t\t\t\t\taccumulator.push( multilineFormat );\n\t\t\t\t\t}\n\n\t\t\t\t\treturn accumulator;\n\t\t\t\t}, [ multilineFormat ] );\n\t\t\t} else {\n\t\t\t\tcharacterFormats = [ ...lastSeparatorFormats, ...( characterFormats || [] ) ];\n\t\t\t}\n\t\t}\n\n\t\tlet pointer = getLastChild( tree );\n\n\t\t// Set selection for the start of line.\n\t\tif ( lastCharacter === LINE_SEPARATOR ) {\n\t\t\tlet node = pointer;\n\n\t\t\twhile ( ! isText( node ) ) {\n\t\t\t\tnode = getLastChild( node );\n\t\t\t}\n\n\t\t\tif ( onStartIndex && start === i ) {\n\t\t\t\tonStartIndex( tree, node );\n\t\t\t}\n\n\t\t\tif ( onEndIndex && end === i ) {\n\t\t\t\tonEndIndex( tree, node );\n\t\t\t}\n\t\t}\n\n\t\tif ( characterFormats ) {\n\t\t\tcharacterFormats.forEach( ( format, formatIndex ) => {\n\t\t\t\tif (\n\t\t\t\t\tpointer &&\n\t\t\t\t\tlastCharacterFormats &&\n\t\t\t\t\tformat === lastCharacterFormats[ formatIndex ] &&\n\t\t\t\t\t// Do not reuse the last element if the character is a\n\t\t\t\t\t// line separator.\n\t\t\t\t\t( character !== LINE_SEPARATOR ||\n\t\t\t\t\t\tcharacterFormats.length - 1 !== formatIndex )\n\t\t\t\t) {\n\t\t\t\t\tpointer = getLastChild( pointer );\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst parent = getParent( pointer );\n\t\t\t\tconst newNode = append( parent, fromFormat( format ) );\n\n\t\t\t\tif ( isText( pointer ) && getText( pointer ).length === 0 ) {\n\t\t\t\t\tremove( pointer );\n\t\t\t\t}\n\n\t\t\t\tpointer = append( format.object ? parent : newNode, '' );\n\t\t\t} );\n\t\t}\n\n\t\t// No need for further processing if the character is a line separator.\n\t\tif ( character === LINE_SEPARATOR ) {\n\t\t\tlastCharacterFormats = characterFormats;\n\t\t\tlastCharacter = character;\n\t\t\tcontinue;\n\t\t}\n\n\t\tpointer = setFormatPlaceholder( pointer, 0 );\n\n\t\t// If there is selection at 0, handle it before characters are inserted.\n\t\tif ( i === 0 ) {\n\t\t\tif ( onStartIndex && start === 0 ) {\n\t\t\t\tonStartIndex( tree, pointer );\n\t\t\t}\n\n\t\t\tif ( onEndIndex && end === 0 ) {\n\t\t\t\tonEndIndex( tree, pointer );\n\t\t\t}\n\t\t}\n\n\t\tif ( character !== OBJECT_REPLACEMENT_CHARACTER ) {\n\t\t\tif ( character === '\\n' ) {\n\t\t\t\tpointer = append( getParent( pointer ), { type: 'br', object: true } );\n\t\t\t\t// Ensure pointer is text node.\n\t\t\t\tpointer = append( getParent( pointer ), '' );\n\t\t\t} else if ( ! isText( pointer ) ) {\n\t\t\t\tpointer = append( getParent( pointer ), character );\n\t\t\t} else {\n\t\t\t\tappendText( pointer, character );\n\t\t\t}\n\t\t}\n\n\t\tpointer = setFormatPlaceholder( pointer, i + 1 );\n\n\t\tif ( onStartIndex && start === i + 1 ) {\n\t\t\tonStartIndex( tree, pointer );\n\t\t}\n\n\t\tif ( onEndIndex && end === i + 1 ) {\n\t\t\tonEndIndex( tree, pointer );\n\t\t}\n\n\t\tlastCharacterFormats = characterFormats;\n\t\tlastCharacter = character;\n\t}\n\n\treturn tree;\n}\n"]}