{"version":3,"sources":["/Users/riad/Workspace/a8c/gutenberg/packages/dom/src/dom.js"],"names":["window","getComputedStyle","Node","TEXT_NODE","ELEMENT_NODE","DOCUMENT_POSITION_PRECEDING","DOCUMENT_POSITION_FOLLOWING","isSelectionForward","selection","anchorNode","focusNode","anchorOffset","focusOffset","position","compareDocumentPosition","isHorizontalEdge","container","isReverse","tagName","selectionStart","selectionEnd","value","length","isContentEditable","getSelection","range","getRangeAt","cloneRange","isCollapsed","collapse","node","startContainer","extentOffset","nodeValue","childNodes","offset","order","parentNode","isVerticalEdge","rangeCount","rangeRect","getRectangleFromRange","buffer","height","editableRect","getBoundingClientRect","top","bottom","collapsed","rect","getClientRects","padNode","document","createTextNode","insertNode","removeChild","computeCaretRect","placeCaretAtHorizontalEdge","focus","rangeTarget","createRange","selectNodeContents","removeAllRanges","addRange","caretRangeFromPoint","doc","x","y","caretPositionFromPoint","point","setStart","offsetNode","hiddenCaretRangeFromPoint","style","zIndex","placeCaretAtVerticalEdge","mayUseScroll","left","contains","scrollIntoView","nodeType","parentRect","side","padding","parseInt","getPropertyValue","actualY","isTextField","element","nodeName","contentEditable","error","documentHasSelection","activeElement","isEntirelySelected","endContainer","startOffset","endOffset","lastChild","lastChildContentLength","data","firstChild","getScrollContainer","scrollHeight","clientHeight","overflowY","test","getOffsetParent","closestElement","offsetParent","replace","processedNode","newNode","insertAfter","remove","referenceNode","insertBefore","nextSibling","unwrap","parent","replaceTag","ownerDocument","createElement","appendChild","replaceChild","wrap"],"mappings":"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","sourcesContent":["/**\n * External dependencies\n */\nimport { includes } from 'lodash';\n\n/**\n * Browser dependencies\n */\n\nconst { getComputedStyle } = window;\nconst {\n\tTEXT_NODE,\n\tELEMENT_NODE,\n\tDOCUMENT_POSITION_PRECEDING,\n\tDOCUMENT_POSITION_FOLLOWING,\n} = window.Node;\n\n/**\n * Returns true if the given selection object is in the forward direction, or\n * false otherwise.\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/API/Node/compareDocumentPosition\n *\n * @param {Selection} selection Selection object to check.\n *\n * @return {boolean} Whether the selection is forward.\n */\nfunction isSelectionForward( selection ) {\n\tconst {\n\t\tanchorNode,\n\t\tfocusNode,\n\t\tanchorOffset,\n\t\tfocusOffset,\n\t} = selection;\n\n\tconst position = anchorNode.compareDocumentPosition( focusNode );\n\n\t// Disable reason: `Node#compareDocumentPosition` returns a bitmask value,\n\t// so bitwise operators are intended.\n\t/* eslint-disable no-bitwise */\n\t// Compare whether anchor node precedes focus node. If focus node (where\n\t// end of selection occurs) is after the anchor node, it is forward.\n\tif ( position & DOCUMENT_POSITION_PRECEDING ) {\n\t\treturn false;\n\t}\n\n\tif ( position & DOCUMENT_POSITION_FOLLOWING ) {\n\t\treturn true;\n\t}\n\t/* eslint-enable no-bitwise */\n\n\t// `compareDocumentPosition` returns 0 when passed the same node, in which\n\t// case compare offsets.\n\tif ( position === 0 ) {\n\t\treturn anchorOffset <= focusOffset;\n\t}\n\n\t// This should never be reached, but return true as default case.\n\treturn true;\n}\n\n/**\n * Check whether the selection is horizontally at the edge of the container.\n *\n * @param {Element} container Focusable element.\n * @param {boolean} isReverse Set to true to check left, false for right.\n *\n * @return {boolean} True if at the horizontal edge, false if not.\n */\nexport function isHorizontalEdge( container, isReverse ) {\n\tif ( includes( [ 'INPUT', 'TEXTAREA' ], container.tagName ) ) {\n\t\tif ( container.selectionStart !== container.selectionEnd ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( isReverse ) {\n\t\t\treturn container.selectionStart === 0;\n\t\t}\n\n\t\treturn container.value.length === container.selectionStart;\n\t}\n\n\tif ( ! container.isContentEditable ) {\n\t\treturn true;\n\t}\n\n\tconst selection = window.getSelection();\n\n\t// Create copy of range for setting selection to find effective offset.\n\tconst range = selection.getRangeAt( 0 ).cloneRange();\n\n\t// Collapse in direction of selection.\n\tif ( ! selection.isCollapsed ) {\n\t\trange.collapse( ! isSelectionForward( selection ) );\n\t}\n\n\tlet node = range.startContainer;\n\n\tlet extentOffset;\n\tif ( isReverse ) {\n\t\t// When in reverse, range node should be first.\n\t\textentOffset = 0;\n\t} else if ( node.nodeValue ) {\n\t\t// Otherwise, vary by node type. A text node has no children. Its range\n\t\t// offset reflects its position in nodeValue.\n\t\t//\n\t\t// \"If the startContainer is a Node of type Text, Comment, or\n\t\t// CDATASection, then the offset is the number of characters from the\n\t\t// start of the startContainer to the boundary point of the Range.\"\n\t\t//\n\t\t// See: https://developer.mozilla.org/en-US/docs/Web/API/Range/startOffset\n\t\t// See: https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeValue\n\t\textentOffset = node.nodeValue.length;\n\t} else {\n\t\t// \"For other Node types, the startOffset is the number of child nodes\n\t\t// between the start of the startContainer and the boundary point of\n\t\t// the Range.\"\n\t\t//\n\t\t// See: https://developer.mozilla.org/en-US/docs/Web/API/Range/startOffset\n\t\textentOffset = node.childNodes.length;\n\t}\n\n\t// Offset of range should be at expected extent.\n\tconst position = isReverse ? 'start' : 'end';\n\tconst offset = range[ `${ position }Offset` ];\n\tif ( offset !== extentOffset ) {\n\t\treturn false;\n\t}\n\n\t// If confirmed to be at extent, traverse up through DOM, verifying that\n\t// the node is at first or last child for reverse or forward respectively.\n\t// Continue until container is reached.\n\tconst order = isReverse ? 'first' : 'last';\n\twhile ( node !== container ) {\n\t\tconst parentNode = node.parentNode;\n\t\tif ( parentNode[ `${ order }Child` ] !== node ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tnode = parentNode;\n\t}\n\n\t// If reached, range is assumed to be at edge.\n\treturn true;\n}\n\n/**\n * Check whether the selection is vertically at the edge of the container.\n *\n * @param {Element} container Focusable element.\n * @param {boolean} isReverse Set to true to check top, false for bottom.\n *\n * @return {boolean} True if at the edge, false if not.\n */\nexport function isVerticalEdge( container, isReverse ) {\n\tif ( includes( [ 'INPUT', 'TEXTAREA' ], container.tagName ) ) {\n\t\treturn isHorizontalEdge( container, isReverse );\n\t}\n\n\tif ( ! container.isContentEditable ) {\n\t\treturn true;\n\t}\n\n\tconst selection = window.getSelection();\n\tconst range = selection.rangeCount ? selection.getRangeAt( 0 ) : null;\n\tif ( ! range ) {\n\t\treturn false;\n\t}\n\n\tconst rangeRect = getRectangleFromRange( range );\n\n\tif ( ! rangeRect ) {\n\t\treturn false;\n\t}\n\n\tconst buffer = rangeRect.height / 2;\n\tconst editableRect = container.getBoundingClientRect();\n\n\t// Too low.\n\tif ( isReverse && rangeRect.top - buffer > editableRect.top ) {\n\t\treturn false;\n\t}\n\n\t// Too high.\n\tif ( ! isReverse && rangeRect.bottom + buffer < editableRect.bottom ) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n/**\n * Get the rectangle of a given Range.\n *\n * @param {Range} range The range.\n *\n * @return {DOMRect} The rectangle.\n */\nexport function getRectangleFromRange( range ) {\n\t// For uncollapsed ranges, get the rectangle that bounds the contents of the\n\t// range; this a rectangle enclosing the union of the bounding rectangles\n\t// for all the elements in the range.\n\tif ( ! range.collapsed ) {\n\t\treturn range.getBoundingClientRect();\n\t}\n\n\tlet rect = range.getClientRects()[ 0 ];\n\n\t// If the collapsed range starts (and therefore ends) at an element node,\n\t// `getClientRects` can be empty in some browsers. This can be resolved\n\t// by adding a temporary text node with zero-width space to the range.\n\t//\n\t// See: https://stackoverflow.com/a/6847328/995445\n\tif ( ! rect ) {\n\t\tconst padNode = document.createTextNode( '\\u200b' );\n\t\trange.insertNode( padNode );\n\t\trect = range.getClientRects()[ 0 ];\n\t\tpadNode.parentNode.removeChild( padNode );\n\t}\n\n\treturn rect;\n}\n\n/**\n * Get the rectangle for the selection in a container.\n *\n * @param {Element} container Editable container.\n *\n * @return {?DOMRect} The rectangle.\n */\nexport function computeCaretRect( container ) {\n\tif ( ! container.isContentEditable ) {\n\t\treturn;\n\t}\n\n\tconst selection = window.getSelection();\n\tconst range = selection.rangeCount ? selection.getRangeAt( 0 ) : null;\n\n\tif ( ! range ) {\n\t\treturn;\n\t}\n\n\treturn getRectangleFromRange( range );\n}\n\n/**\n * Places the caret at start or end of a given element.\n *\n * @param {Element} container Focusable element.\n * @param {boolean} isReverse True for end, false for start.\n */\nexport function placeCaretAtHorizontalEdge( container, isReverse ) {\n\tif ( ! container ) {\n\t\treturn;\n\t}\n\n\tif ( includes( [ 'INPUT', 'TEXTAREA' ], container.tagName ) ) {\n\t\tcontainer.focus();\n\t\tif ( isReverse ) {\n\t\t\tcontainer.selectionStart = container.value.length;\n\t\t\tcontainer.selectionEnd = container.value.length;\n\t\t} else {\n\t\t\tcontainer.selectionStart = 0;\n\t\t\tcontainer.selectionEnd = 0;\n\t\t}\n\t\treturn;\n\t}\n\n\tcontainer.focus();\n\n\tif ( ! container.isContentEditable ) {\n\t\treturn;\n\t}\n\n\t// Select on extent child of the container, not the container itself. This\n\t// avoids the selection always being `endOffset` of 1 when placed at end,\n\t// where `startContainer`, `endContainer` would always be container itself.\n\tconst rangeTarget = container[ isReverse ? 'lastChild' : 'firstChild' ];\n\n\t// If no range target, it implies that the container is empty. Focusing is\n\t// sufficient for caret to be placed correctly.\n\tif ( ! rangeTarget ) {\n\t\treturn;\n\t}\n\n\tconst selection = window.getSelection();\n\tconst range = document.createRange();\n\n\trange.selectNodeContents( rangeTarget );\n\trange.collapse( ! isReverse );\n\n\tselection.removeAllRanges();\n\tselection.addRange( range );\n}\n\n/**\n * Polyfill.\n * Get a collapsed range for a given point.\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/caretRangeFromPoint\n *\n * @param {Document} doc The document of the range.\n * @param {number}    x   Horizontal position within the current viewport.\n * @param {number}    y   Vertical position within the current viewport.\n *\n * @return {?Range} The best range for the given point.\n */\nfunction caretRangeFromPoint( doc, x, y ) {\n\tif ( doc.caretRangeFromPoint ) {\n\t\treturn doc.caretRangeFromPoint( x, y );\n\t}\n\n\tif ( ! doc.caretPositionFromPoint ) {\n\t\treturn null;\n\t}\n\n\tconst point = doc.caretPositionFromPoint( x, y );\n\n\t// If x or y are negative, outside viewport, or there is no text entry node.\n\t// https://developer.mozilla.org/en-US/docs/Web/API/Document/caretRangeFromPoint\n\tif ( ! point ) {\n\t\treturn null;\n\t}\n\n\tconst range = doc.createRange();\n\n\trange.setStart( point.offsetNode, point.offset );\n\trange.collapse( true );\n\n\treturn range;\n}\n\n/**\n * Get a collapsed range for a given point.\n * Gives the container a temporary high z-index (above any UI).\n * This is preferred over getting the UI nodes and set styles there.\n *\n * @param {Document} doc       The document of the range.\n * @param {number}    x         Horizontal position within the current viewport.\n * @param {number}    y         Vertical position within the current viewport.\n * @param {Element}  container Container in which the range is expected to be found.\n *\n * @return {?Range} The best range for the given point.\n */\nfunction hiddenCaretRangeFromPoint( doc, x, y, container ) {\n\tcontainer.style.zIndex = '10000';\n\n\tconst range = caretRangeFromPoint( doc, x, y );\n\n\tcontainer.style.zIndex = null;\n\n\treturn range;\n}\n\n/**\n * Places the caret at the top or bottom of a given element.\n *\n * @param {Element} container           Focusable element.\n * @param {boolean} isReverse           True for bottom, false for top.\n * @param {DOMRect} [rect]              The rectangle to position the caret with.\n * @param {boolean} [mayUseScroll=true] True to allow scrolling, false to disallow.\n */\nexport function placeCaretAtVerticalEdge( container, isReverse, rect, mayUseScroll = true ) {\n\tif ( ! container ) {\n\t\treturn;\n\t}\n\n\tif ( ! rect || ! container.isContentEditable ) {\n\t\tplaceCaretAtHorizontalEdge( container, isReverse );\n\t\treturn;\n\t}\n\n\t// Offset by a buffer half the height of the caret rect. This is needed\n\t// because caretRangeFromPoint may default to the end of the selection if\n\t// offset is too close to the edge. It's unclear how to precisely calculate\n\t// this threshold; it may be the padded area of some combination of line\n\t// height, caret height, and font size. The buffer offset is effectively\n\t// equivalent to a point at half the height of a line of text.\n\tconst buffer = rect.height / 2;\n\tconst editableRect = container.getBoundingClientRect();\n\tconst x = rect.left;\n\tconst y = isReverse ? ( editableRect.bottom - buffer ) : ( editableRect.top + buffer );\n\n\tlet range = hiddenCaretRangeFromPoint( document, x, y, container );\n\n\tif ( ! range || ! container.contains( range.startContainer ) ) {\n\t\tif ( mayUseScroll && (\n\t\t\t( ! range || ! range.startContainer ) ||\n\t\t\t\t! range.startContainer.contains( container ) ) ) {\n\t\t\t// Might be out of view.\n\t\t\t// Easier than attempting to calculate manually.\n\t\t\tcontainer.scrollIntoView( isReverse );\n\t\t\tplaceCaretAtVerticalEdge( container, isReverse, rect, false );\n\t\t\treturn;\n\t\t}\n\n\t\tplaceCaretAtHorizontalEdge( container, isReverse );\n\t\treturn;\n\t}\n\n\t// Check if the closest text node is actually further away.\n\t// If so, attempt to get the range again with the y position adjusted to get the right offset.\n\tif ( range.startContainer.nodeType === TEXT_NODE ) {\n\t\tconst parentNode = range.startContainer.parentNode;\n\t\tconst parentRect = parentNode.getBoundingClientRect();\n\t\tconst side = isReverse ? 'bottom' : 'top';\n\t\tconst padding = parseInt( getComputedStyle( parentNode ).getPropertyValue( `padding-${ side }` ), 10 ) || 0;\n\t\tconst actualY = isReverse ? ( parentRect.bottom - padding - buffer ) : ( parentRect.top + padding + buffer );\n\n\t\tif ( y !== actualY ) {\n\t\t\trange = hiddenCaretRangeFromPoint( document, x, actualY, container );\n\t\t}\n\t}\n\n\tconst selection = window.getSelection();\n\tselection.removeAllRanges();\n\tselection.addRange( range );\n\tcontainer.focus();\n\t// Editable was already focussed, it goes back to old range...\n\t// This fixes it.\n\tselection.removeAllRanges();\n\tselection.addRange( range );\n}\n\n/**\n * Check whether the given element is a text field, where text field is defined\n * by the ability to select within the input, or that it is contenteditable.\n *\n * See: https://html.spec.whatwg.org/#textFieldSelection\n *\n * @param {HTMLElement} element The HTML element.\n *\n * @return {boolean} True if the element is an text field, false if not.\n */\nexport function isTextField( element ) {\n\ttry {\n\t\tconst { nodeName, selectionStart, contentEditable } = element;\n\n\t\treturn (\n\t\t\t( nodeName === 'INPUT' && selectionStart !== null ) ||\n\t\t\t( nodeName === 'TEXTAREA' ) ||\n\t\t\tcontentEditable === 'true'\n\t\t);\n\t} catch ( error ) {\n\t\t// Safari throws an exception when trying to get `selectionStart`\n\t\t// on non-text <input> elements (which, understandably, don't\n\t\t// have the text selection API). We catch this via a try/catch\n\t\t// block, as opposed to a more explicit check of the element's\n\t\t// input types, because of Safari's non-standard behavior. This\n\t\t// also means we don't have to worry about the list of input\n\t\t// types that support `selectionStart` changing as the HTML spec\n\t\t// evolves over time.\n\t\treturn false;\n\t}\n}\n\n/**\n * Check wether the current document has a selection.\n * This checks both for focus in an input field and general text selection.\n *\n * @return {boolean} True if there is selection, false if not.\n */\nexport function documentHasSelection() {\n\tif ( isTextField( document.activeElement ) ) {\n\t\treturn true;\n\t}\n\n\tconst selection = window.getSelection();\n\tconst range = selection.rangeCount ? selection.getRangeAt( 0 ) : null;\n\n\treturn range && ! range.collapsed;\n}\n\n/**\n * Check whether the contents of the element have been entirely selected.\n * Returns true if there is no possibility of selection.\n *\n * @param {Element} element The element to check.\n *\n * @return {boolean} True if entirely selected, false if not.\n */\nexport function isEntirelySelected( element ) {\n\tif ( includes( [ 'INPUT', 'TEXTAREA' ], element.nodeName ) ) {\n\t\treturn element.selectionStart === 0 && element.value.length === element.selectionEnd;\n\t}\n\n\tif ( ! element.isContentEditable ) {\n\t\treturn true;\n\t}\n\n\tconst selection = window.getSelection();\n\tconst range = selection.rangeCount ? selection.getRangeAt( 0 ) : null;\n\n\tif ( ! range ) {\n\t\treturn true;\n\t}\n\n\tconst { startContainer, endContainer, startOffset, endOffset } = range;\n\n\tif (\n\t\tstartContainer === element &&\n\t\tendContainer === element &&\n\t\tstartOffset === 0 &&\n\t\tendOffset === element.childNodes.length\n\t) {\n\t\treturn true;\n\t}\n\n\tconst lastChild = element.lastChild;\n\tconst lastChildContentLength = lastChild.nodeType === TEXT_NODE ?\n\t\tlastChild.data.length :\n\t\tlastChild.childNodes.length;\n\n\treturn (\n\t\tstartContainer === element.firstChild &&\n\t\tendContainer === element.lastChild &&\n\t\tstartOffset === 0 &&\n\t\tendOffset === lastChildContentLength\n\t);\n}\n\n/**\n * Given a DOM node, finds the closest scrollable container node.\n *\n * @param {Element} node Node from which to start.\n *\n * @return {?Element} Scrollable container node, if found.\n */\nexport function getScrollContainer( node ) {\n\tif ( ! node ) {\n\t\treturn;\n\t}\n\n\t// Scrollable if scrollable height exceeds displayed...\n\tif ( node.scrollHeight > node.clientHeight ) {\n\t\t// ...except when overflow is defined to be hidden or visible\n\t\tconst { overflowY } = window.getComputedStyle( node );\n\t\tif ( /(auto|scroll)/.test( overflowY ) ) {\n\t\t\treturn node;\n\t\t}\n\t}\n\n\t// Continue traversing\n\treturn getScrollContainer( node.parentNode );\n}\n\n/**\n * Returns the closest positioned element, or null under any of the conditions\n * of the offsetParent specification. Unlike offsetParent, this function is not\n * limited to HTMLElement and accepts any Node (e.g. Node.TEXT_NODE).\n *\n * @see https://drafts.csswg.org/cssom-view/#dom-htmlelement-offsetparent\n *\n * @param {Node} node Node from which to find offset parent.\n *\n * @return {?Node} Offset parent.\n */\nexport function getOffsetParent( node ) {\n\t// Cannot retrieve computed style or offset parent only anything other than\n\t// an element node, so find the closest element node.\n\tlet closestElement;\n\twhile ( ( closestElement = node.parentNode ) ) {\n\t\tif ( closestElement.nodeType === ELEMENT_NODE ) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif ( ! closestElement ) {\n\t\treturn null;\n\t}\n\n\t// If the closest element is already positioned, return it, as offsetParent\n\t// does not otherwise consider the node itself.\n\tif ( getComputedStyle( closestElement ).position !== 'static' ) {\n\t\treturn closestElement;\n\t}\n\n\treturn closestElement.offsetParent;\n}\n\n/**\n * Given two DOM nodes, replaces the former with the latter in the DOM.\n *\n * @param {Element} processedNode Node to be removed.\n * @param {Element} newNode       Node to be inserted in its place.\n * @return {void}\n */\nexport function replace( processedNode, newNode ) {\n\tinsertAfter( newNode, processedNode.parentNode );\n\tremove( processedNode );\n}\n\n/**\n * Given a DOM node, removes it from the DOM.\n *\n * @param {Element} node Node to be removed.\n * @return {void}\n */\nexport function remove( node ) {\n\tnode.parentNode.removeChild( node );\n}\n\n/**\n * Given two DOM nodes, inserts the former in the DOM as the next sibling of\n * the latter.\n *\n * @param {Element} newNode       Node to be inserted.\n * @param {Element} referenceNode Node after which to perform the insertion.\n * @return {void}\n */\nexport function insertAfter( newNode, referenceNode ) {\n\treferenceNode.parentNode.insertBefore( newNode, referenceNode.nextSibling );\n}\n\n/**\n * Unwrap the given node. This means any child nodes are moved to the parent.\n *\n * @param {Node} node The node to unwrap.\n *\n * @return {void}\n */\nexport function unwrap( node ) {\n\tconst parent = node.parentNode;\n\n\twhile ( node.firstChild ) {\n\t\tparent.insertBefore( node.firstChild, node );\n\t}\n\n\tparent.removeChild( node );\n}\n\n/**\n * Replaces the given node with a new node with the given tag name.\n *\n * @param {Element}  node    The node to replace\n * @param {string}   tagName The new tag name.\n *\n * @return {Element} The new node.\n */\nexport function replaceTag( node, tagName ) {\n\tconst newNode = node.ownerDocument.createElement( tagName );\n\n\twhile ( node.firstChild ) {\n\t\tnewNode.appendChild( node.firstChild );\n\t}\n\n\tnode.parentNode.replaceChild( newNode, node );\n\n\treturn newNode;\n}\n\n/**\n * Wraps the given node with a new node with the given tag name.\n *\n * @param {Element} newNode       The node to insert.\n * @param {Element} referenceNode The node to wrap.\n */\nexport function wrap( newNode, referenceNode ) {\n\treferenceNode.parentNode.insertBefore( newNode, referenceNode );\n\tnewNode.appendChild( referenceNode );\n}\n"]}