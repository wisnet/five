{"version":3,"sources":["/Users/riad/Workspace/a8c/gutenberg/packages/data/src/resolvers-cache-middleware.js"],"names":["get","createResolversCacheMiddleware","registry","reducerKey","next","action","resolvers","select","getCachedResolvers","Object","entries","forEach","selectorName","resolversByArgs","resolver","namespaces","shouldInvalidate","value","args","dispatch","invalidateResolution"],"mappings":";;;AAAA;;;AAGA,SAASA,GAAT,QAAoB,QAApB;AAEA;;;;;;;;;AAQA,IAAMC,8BAA8B,GAAG,SAAjCA,8BAAiC,CAAEC,QAAF,EAAYC,UAAZ;AAAA,SAA4B;AAAA,WAAM,UAAEC,IAAF;AAAA,aAAY,UAAEC,MAAF,EAAc;AAClG,YAAMC,SAAS,GAAGJ,QAAQ,CAACK,MAAT,CAAiB,WAAjB,EAA+BC,kBAA/B,CAAmDL,UAAnD,CAAlB;AACAM,QAAAA,MAAM,CAACC,OAAP,CAAgBJ,SAAhB,EAA4BK,OAA5B,CAAqC,gBAAyC;AAAA;AAAA,cAArCC,YAAqC;AAAA,cAAvBC,eAAuB;;AAC7E,cAAMC,QAAQ,GAAGd,GAAG,CAAEE,QAAQ,CAACa,UAAX,EAAuB,CAAEZ,UAAF,EAAc,WAAd,EAA2BS,YAA3B,CAAvB,CAApB;;AACA,cAAK,CAAEE,QAAF,IAAc,CAAEA,QAAQ,CAACE,gBAA9B,EAAiD;AAChD;AACA;;AACDH,UAAAA,eAAe,CAACF,OAAhB,CAAyB,UAAEM,KAAF,EAASC,IAAT,EAAmB;AAC3C;AACA;AACA;AACA,gBAAKD,KAAK,KAAK,KAAV,IAAmB,CAAEH,QAAQ,CAACE,gBAAT,OAAAF,QAAQ,GAAmBT,MAAnB,4BAA8Ba,IAA9B,GAAlC,EAAyE;AACxE;AACA,aAN0C,CAQ3C;;;AACAhB,YAAAA,QAAQ,CAACiB,QAAT,CAAmB,WAAnB,EAAiCC,oBAAjC,CAAuDjB,UAAvD,EAAmES,YAAnE,EAAiFM,IAAjF;AACA,WAVD;AAWA,SAhBD;AAiBAd,QAAAA,IAAI,CAAEC,MAAF,CAAJ;AACA,OApBwE;AAAA,KAAN;AAAA,GAA5B;AAAA,CAAvC;;AAsBA,eAAeJ,8BAAf","sourcesContent":["/**\n * External dependencies\n */\nimport { get } from 'lodash';\n\n/**\n * creates a middleware handling resolvers cache invalidation.\n *\n * @param {Object} registry\n * @param {string} reducerKey\n *\n * @return {function} middleware\n */\nconst createResolversCacheMiddleware = ( registry, reducerKey ) => () => ( next ) => ( action ) => {\n\tconst resolvers = registry.select( 'core/data' ).getCachedResolvers( reducerKey );\n\tObject.entries( resolvers ).forEach( ( [ selectorName, resolversByArgs ] ) => {\n\t\tconst resolver = get( registry.namespaces, [ reducerKey, 'resolvers', selectorName ] );\n\t\tif ( ! resolver || ! resolver.shouldInvalidate ) {\n\t\t\treturn;\n\t\t}\n\t\tresolversByArgs.forEach( ( value, args ) => {\n\t\t\t// resolversByArgs is the map Map([ args ] => boolean) storing the cache resolution status for a given selector.\n\t\t\t// If the value is false it means this resolver has finished its resolution which means we need to invalidate it,\n\t\t\t// if it's true it means it's inflight and the invalidation is not necessary.\n\t\t\tif ( value !== false || ! resolver.shouldInvalidate( action, ...args ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Trigger cache invalidation\n\t\t\tregistry.dispatch( 'core/data' ).invalidateResolution( reducerKey, selectorName, args );\n\t\t} );\n\t} );\n\tnext( action );\n};\n\nexport default createResolversCacheMiddleware;\n"]}